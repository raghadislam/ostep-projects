0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 int             getreadcount(void);
0376 
0377 
0378 void            swtch(struct context**, struct context*);
0379 
0380 
0381 void            acquire(struct spinlock*);
0382 void            getcallerpcs(void*, uint*);
0383 int             holding(struct spinlock*);
0384 void            initlock(struct spinlock*, char*);
0385 void            release(struct spinlock*);
0386 void            pushcli(void);
0387 void            popcli(void);
0388 
0389 
0390 void            acquiresleep(struct sleeplock*);
0391 void            releasesleep(struct sleeplock*);
0392 int             holdingsleep(struct sleeplock*);
0393 void            initsleeplock(struct sleeplock*, char*);
0394 
0395 
0396 int             memcmp(const void*, const void*, uint);
0397 void*           memmove(void*, const void*, uint);
0398 void*           memset(void*, int, uint);
0399 char*           safestrcpy(char*, const char*, int);
0400 int             strlen(const char*);
0401 int             strncmp(const char*, const char*, uint);
0402 char*           strncpy(char*, const char*, int);
0403 
0404 
0405 int             argint(int, int*);
0406 int             argptr(int, char**, int);
0407 int             argstr(int, char**);
0408 int             fetchint(uint, int*);
0409 int             fetchstr(uint, char**);
0410 void            syscall(void);
0411 
0412 
0413 void            timerinit(void);
0414 
0415 
0416 void            idtinit(void);
0417 extern uint     ticks;
0418 void            tvinit(void);
0419 extern struct spinlock tickslock;
0420 
0421 
0422 void            uartinit(void);
0423 void            uartintr(void);
0424 void            uartputc(int);
0425 
0426 
0427 void            seginit(void);
0428 void            kvmalloc(void);
0429 pde_t*          setupkvm(void);
0430 char*           uva2ka(pde_t*, char*);
0431 int             allocuvm(pde_t*, uint, uint);
0432 int             deallocuvm(pde_t*, uint, uint);
0433 void            freevm(pde_t*);
0434 void            inituvm(pde_t*, char*, uint);
0435 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0436 pde_t*          copyuvm(pde_t*, uint);
0437 void            switchuvm(struct proc*);
0438 void            switchkvm(void);
0439 int             copyout(pde_t*, uint, void*, uint);
0440 void            clearpteu(pde_t *pgdir, char *uva);
0441 
0442 
0443 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_W     0x2       
0667 #define STA_R     0x2       
0668 
0669 
0670 
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_IF           0x00000200      
0705 
0706 
0707 #define CR0_PE          0x00000001      
0708 #define CR0_WP          0x00010000      
0709 #define CR0_PG          0x80000000      
0710 
0711 #define CR4_PSE         0x00000010      
0712 
0713 
0714 #define SEG_KCODE 1  
0715 #define SEG_KDATA 2  
0716 #define SEG_UCODE 3  
0717 #define SEG_UDATA 4  
0718 #define SEG_TSS   5  
0719 
0720 
0721 #define NSEGS     6
0722 
0723 #ifndef __ASSEMBLER__
0724 
0725 struct segdesc {
0726   uint lim_15_0 : 16;  
0727   uint base_15_0 : 16; 
0728   uint base_23_16 : 8; 
0729   uint type : 4;       
0730   uint s : 1;          
0731   uint dpl : 2;        
0732   uint p : 1;          
0733   uint lim_19_16 : 4;  
0734   uint avl : 1;        
0735   uint rsv1 : 1;       
0736   uint db : 1;         
0737   uint g : 1;          
0738   uint base_31_24 : 8; 
0739 };
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0752 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0753   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0754   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0755 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0756 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0757   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0758   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0759 #endif
0760 
0761 #define DPL_USER    0x3     
0762 
0763 
0764 #define STA_X       0x8     
0765 #define STA_W       0x2     
0766 #define STA_R       0x2     
0767 
0768 
0769 #define STS_T32A    0x9     
0770 #define STS_IG32    0xE     
0771 #define STS_TG32    0xF     
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0783 
0784 
0785 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0786 
0787 
0788 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0789 
0790 
0791 #define NPDENTRIES      1024    
0792 #define NPTENTRIES      1024    
0793 #define PGSIZE          4096    
0794 
0795 #define PTXSHIFT        12      
0796 #define PDXSHIFT        22      
0797 
0798 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0799 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0800 
0801 #define PTE_P           0x001   
0802 #define PTE_W           0x002   
0803 #define PTE_U           0x004   
0804 #define PTE_PS          0x080   
0805 
0806 
0807 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0808 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0809 
0810 #ifndef __ASSEMBLER__
0811 typedef uint pte_t;
0812 
0813 
0814 struct taskstate {
0815   uint link;         
0816   uint esp0;         
0817   ushort ss0;        
0818   ushort padding1;
0819   uint *esp1;
0820   ushort ss1;
0821   ushort padding2;
0822   uint *esp2;
0823   ushort ss2;
0824   ushort padding3;
0825   void *cr3;         
0826   uint *eip;         
0827   uint eflags;
0828   uint eax;          
0829   uint ecx;
0830   uint edx;
0831   uint ebx;
0832   uint *esp;
0833   uint *ebp;
0834   uint esi;
0835   uint edi;
0836   ushort es;         
0837   ushort padding4;
0838   ushort cs;
0839   ushort padding5;
0840   ushort ss;
0841   ushort padding6;
0842   ushort ds;
0843   ushort padding7;
0844   ushort fs;
0845   ushort padding8;
0846   ushort gs;
0847   ushort padding9;
0848   ushort ldt;
0849   ushort padding10;
0850   ushort t;          
0851   ushort iomb;       
0852 };
0853 
0854 
0855 struct gatedesc {
0856   uint off_15_0 : 16;   
0857   uint cs : 16;         
0858   uint args : 5;        
0859   uint rsv1 : 3;        
0860   uint type : 4;        
0861   uint s : 1;           
0862   uint dpl : 2;         
0863   uint p : 1;           
0864   uint off_31_16 : 16;  
0865 };
0866 
0867 
0868 
0869 
0870 
0871 
0872 
0873 
0874 
0875 #define SETGATE(gate, istrap, sel, off, d)                \
0876 {                                                         \
0877   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0878   (gate).cs = (sel);                                      \
0879   (gate).args = 0;                                        \
0880   (gate).rsv1 = 0;                                        \
0881   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0882   (gate).s = 0;                                           \
0883   (gate).dpl = (d);                                       \
0884   (gate).p = 1;                                           \
0885   (gate).off_31_16 = (uint)(off) >> 16;                  \
0886 }
0887 
0888 #endif
0889 
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 
0902 #define ELF_MAGIC 0x464C457FU  
0903 
0904 
0905 struct elfhdr {
0906   uint magic;  
0907   uchar elf[12];
0908   ushort type;
0909   ushort machine;
0910   uint version;
0911   uint entry;
0912   uint phoff;
0913   uint shoff;
0914   uint flags;
0915   ushort ehsize;
0916   ushort phentsize;
0917   ushort phnum;
0918   ushort shentsize;
0919   ushort shnum;
0920   ushort shstrndx;
0921 };
0922 
0923 
0924 struct proghdr {
0925   uint type;
0926   uint off;
0927   uint vaddr;
0928   uint paddr;
0929   uint filesz;
0930   uint memsz;
0931   uint flags;
0932   uint align;
0933 };
0934 
0935 
0936 #define ELF_PROG_LOAD           1
0937 
0938 
0939 #define ELF_PROG_FLAG_EXEC      1
0940 #define ELF_PROG_FLAG_WRITE     2
0941 #define ELF_PROG_FLAG_READ      4
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 struct rtcdate {
0951   uint second;
0952   uint minute;
0953   uint hour;
0954   uint day;
0955   uint month;
0956   uint year;
0957 };
0958 
0959 
0960 
0961 
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 
0972 
0973 
0974 
0975 
0976 
0977 
0978 
0979 
0980 
0981 
0982 
0983 
0984 
0985 
0986 
0987 
0988 
0989 
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 
1043 .globl entry
1044 entry:
1045   
1046   movl    %cr4, %eax
1047   orl     $(CR4_PSE), %eax
1048   movl    %eax, %cr4
1049   
1050   movl    $(V2P_WO(entrypgdir)), %eax
1051   movl    %eax, %cr3
1052   
1053   movl    %cr0, %eax
1054   orl     $(CR0_PG|CR0_WP), %eax
1055   movl    %eax, %cr0
1056 
1057   
1058   movl $(stack + KSTACKSIZE), %esp
1059 
1060   
1061   
1062   
1063   
1064   mov $main, %eax
1065   jmp *%eax
1066 
1067 .comm stack, KSTACKSIZE
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 
1146 
1147 
1148 
1149 
1150 .code32  
1151 start32:
1152   
1153   movw    $(SEG_KDATA<<3), %ax    
1154   movw    %ax, %ds                
1155   movw    %ax, %es                
1156   movw    %ax, %ss                
1157   movw    $0, %ax                 
1158   movw    %ax, %fs                
1159   movw    %ax, %gs                
1160 
1161   
1162   movl    %cr4, %eax
1163   orl     $(CR4_PSE), %eax
1164   movl    %eax, %cr4
1165   
1166   movl    (start-12), %eax
1167   movl    %eax, %cr3
1168   
1169   movl    %cr0, %eax
1170   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1171   movl    %eax, %cr0
1172 
1173   
1174   movl    (start-4), %esp
1175   
1176   call	 *(start-8)
1177 
1178   movw    $0x8a00, %ax
1179   movw    %ax, %dx
1180   outw    %ax, %dx
1181   movw    $0x8ae0, %ax
1182   outw    %ax, %dx
1183 spin:
1184   jmp     spin
1185 
1186 .p2align 2
1187 gdt:
1188   SEG_NULLASM
1189   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1190   SEG_ASM(STA_W, 0, 0xffffffff)
1191 
1192 
1193 gdtdesc:
1194   .word   (gdtdesc - gdt - 1)
1195   .long   gdt
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();     
1223   seginit();       
1224   picinit();       
1225   ioapicinit();    
1226   consoleinit();   
1227   uartinit();      
1228   pinit();         
1229   tvinit();        
1230   binit();         
1231   fileinit();      
1232   ideinit();       
1233   startothers();   
1234   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1235   userinit();      
1236   mpmain();        
1237 }
1238 
1239 
1240 static void
1241 mpenter(void)
1242 {
1243   switchkvm();
1244   seginit();
1245   lapicinit();
1246   mpmain();
1247 }
1248 
1249 
1250 
1251 static void
1252 mpmain(void)
1253 {
1254   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1255   idtinit();       
1256   xchg(&(mycpu()->started), 1); 
1257   scheduler();     
1258 }
1259 
1260 pde_t entrypgdir[];  
1261 
1262 
1263 static void
1264 startothers(void)
1265 {
1266   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1267   uchar *code;
1268   struct cpu *c;
1269   char *stack;
1270 
1271   
1272   
1273   
1274   code = P2V(0x7000);
1275   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1276 
1277   for(c = cpus; c < cpus+ncpu; c++){
1278     if(c == mycpu())  
1279       continue;
1280 
1281     
1282     
1283     
1284     stack = kalloc();
1285     *(void**)(code-4) = stack + KSTACKSIZE;
1286     *(void(**)(void))(code-8) = mpenter;
1287     *(int**)(code-12) = (void *) V2P(entrypgdir);
1288 
1289     lapicstartap(c->apicid, V2P(code));
1290 
1291     
1292     while(c->started == 0)
1293       ;
1294   }
1295 }
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 __attribute__((__aligned__(PGSIZE)))
1306 pde_t entrypgdir[NPDENTRIES] = {
1307   
1308   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1309   
1310   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1311 };
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 struct spinlock {
1502   uint locked;       
1503 
1504   
1505   char *name;        
1506   struct cpu *cpu;   
1507   uint pcs[10];      
1508                      
1509 };
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 #include "types.h"
1553 #include "defs.h"
1554 #include "param.h"
1555 #include "x86.h"
1556 #include "memlayout.h"
1557 #include "mmu.h"
1558 #include "proc.h"
1559 #include "spinlock.h"
1560 
1561 void
1562 initlock(struct spinlock *lk, char *name)
1563 {
1564   lk->name = name;
1565   lk->locked = 0;
1566   lk->cpu = 0;
1567 }
1568 
1569 
1570 
1571 
1572 
1573 void
1574 acquire(struct spinlock *lk)
1575 {
1576   pushcli(); 
1577   if(holding(lk))
1578     panic("acquire");
1579 
1580   
1581   while(xchg(&lk->locked, 1) != 0)
1582     ;
1583 
1584   
1585   
1586   
1587   __sync_synchronize();
1588 
1589   
1590   lk->cpu = mycpu();
1591   getcallerpcs(&lk, lk->pcs);
1592 }
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 void
1602 release(struct spinlock *lk)
1603 {
1604   if(!holding(lk))
1605     panic("release");
1606 
1607   lk->pcs[0] = 0;
1608   lk->cpu = 0;
1609 
1610   
1611   
1612   
1613   
1614   
1615   __sync_synchronize();
1616 
1617   
1618   
1619   
1620   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1621 
1622   popcli();
1623 }
1624 
1625 
1626 void
1627 getcallerpcs(void *v, uint pcs[])
1628 {
1629   uint *ebp;
1630   int i;
1631 
1632   ebp = (uint*)v - 2;
1633   for(i = 0; i < 10; i++){
1634     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1635       break;
1636     pcs[i] = ebp[1];     
1637     ebp = (uint*)ebp[0]; 
1638   }
1639   for(; i < 10; i++)
1640     pcs[i] = 0;
1641 }
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 int
1652 holding(struct spinlock *lock)
1653 {
1654   int r;
1655   pushcli();
1656   r = lock->locked && lock->cpu == mycpu();
1657   popcli();
1658   return r;
1659 }
1660 
1661 
1662 
1663 
1664 
1665 
1666 void
1667 pushcli(void)
1668 {
1669   int eflags;
1670 
1671   eflags = readeflags();
1672   cli();
1673   if(mycpu()->ncli == 0)
1674     mycpu()->intena = eflags & FL_IF;
1675   mycpu()->ncli += 1;
1676 }
1677 
1678 void
1679 popcli(void)
1680 {
1681   if(readeflags()&FL_IF)
1682     panic("popcli - interruptible");
1683   if(--mycpu()->ncli < 0)
1684     panic("popcli");
1685   if(mycpu()->ncli == 0 && mycpu()->intena)
1686     sti();
1687 }
1688 
1689 
1690 
1691 
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 #include "param.h"
1701 #include "types.h"
1702 #include "defs.h"
1703 #include "x86.h"
1704 #include "memlayout.h"
1705 #include "mmu.h"
1706 #include "proc.h"
1707 #include "elf.h"
1708 
1709 extern char data[];  
1710 pde_t *kpgdir;  
1711 
1712 
1713 
1714 void
1715 seginit(void)
1716 {
1717   struct cpu *c;
1718 
1719   
1720   
1721   
1722   
1723   c = &cpus[cpuid()];
1724   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1725   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1726   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1727   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1728   lgdt(c->gdt, sizeof(c->gdt));
1729 }
1730 
1731 
1732 
1733 
1734 static pte_t *
1735 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1736 {
1737   pde_t *pde;
1738   pte_t *pgtab;
1739 
1740   pde = &pgdir[PDX(va)];
1741   if(*pde & PTE_P){
1742     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1743   } else {
1744     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1745       return 0;
1746     
1747     memset(pgtab, 0, PGSIZE);
1748     
1749     
1750     
1751     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1752   }
1753   return &pgtab[PTX(va)];
1754 }
1755 
1756 
1757 
1758 
1759 static int
1760 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1761 {
1762   char *a, *last;
1763   pte_t *pte;
1764 
1765   a = (char*)PGROUNDDOWN((uint)va);
1766   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1767   for(;;){
1768     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1769       return -1;
1770     if(*pte & PTE_P)
1771       panic("remap");
1772     *pte = pa | perm | PTE_P;
1773     if(a == last)
1774       break;
1775     a += PGSIZE;
1776     pa += PGSIZE;
1777   }
1778   return 0;
1779 }
1780 
1781 
1782 
1783 
1784 
1785 
1786 
1787 
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 
1803 
1804 static struct kmap {
1805   void *virt;
1806   uint phys_start;
1807   uint phys_end;
1808   int perm;
1809 } kmap[] = {
1810  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1811  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1812  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1813  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1814 };
1815 
1816 
1817 pde_t*
1818 setupkvm(void)
1819 {
1820   pde_t *pgdir;
1821   struct kmap *k;
1822 
1823   if((pgdir = (pde_t*)kalloc()) == 0)
1824     return 0;
1825   memset(pgdir, 0, PGSIZE);
1826   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1827     panic("PHYSTOP too high");
1828   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1829     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1830                 (uint)k->phys_start, k->perm) < 0) {
1831       freevm(pgdir);
1832       return 0;
1833     }
1834   return pgdir;
1835 }
1836 
1837 
1838 
1839 void
1840 kvmalloc(void)
1841 {
1842   kpgdir = setupkvm();
1843   switchkvm();
1844 }
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 void
1853 switchkvm(void)
1854 {
1855   lcr3(V2P(kpgdir));   
1856 }
1857 
1858 
1859 void
1860 switchuvm(struct proc *p)
1861 {
1862   if(p == 0)
1863     panic("switchuvm: no process");
1864   if(p->kstack == 0)
1865     panic("switchuvm: no kstack");
1866   if(p->pgdir == 0)
1867     panic("switchuvm: no pgdir");
1868 
1869   pushcli();
1870   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1871                                 sizeof(mycpu()->ts)-1, 0);
1872   mycpu()->gdt[SEG_TSS].s = 0;
1873   mycpu()->ts.ss0 = SEG_KDATA << 3;
1874   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1875   
1876   
1877   mycpu()->ts.iomb = (ushort) 0xFFFF;
1878   ltr(SEG_TSS << 3);
1879   lcr3(V2P(p->pgdir));  
1880   popcli();
1881 }
1882 
1883 
1884 
1885 void
1886 inituvm(pde_t *pgdir, char *init, uint sz)
1887 {
1888   char *mem;
1889 
1890   if(sz >= PGSIZE)
1891     panic("inituvm: more than a page");
1892   mem = kalloc();
1893   memset(mem, 0, PGSIZE);
1894   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1895   memmove(mem, init, sz);
1896 }
1897 
1898 
1899 
1900 
1901 
1902 int
1903 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1904 {
1905   uint i, pa, n;
1906   pte_t *pte;
1907 
1908   if((uint) addr % PGSIZE != 0)
1909     panic("loaduvm: addr must be page aligned");
1910   for(i = 0; i < sz; i += PGSIZE){
1911     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1912       panic("loaduvm: address should exist");
1913     pa = PTE_ADDR(*pte);
1914     if(sz - i < PGSIZE)
1915       n = sz - i;
1916     else
1917       n = PGSIZE;
1918     if(readi(ip, P2V(pa), offset+i, n) != n)
1919       return -1;
1920   }
1921   return 0;
1922 }
1923 
1924 
1925 
1926 int
1927 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1928 {
1929   char *mem;
1930   uint a;
1931 
1932   if(newsz >= KERNBASE)
1933     return 0;
1934   if(newsz < oldsz)
1935     return oldsz;
1936 
1937   a = PGROUNDUP(oldsz);
1938   for(; a < newsz; a += PGSIZE){
1939     mem = kalloc();
1940     if(mem == 0){
1941       cprintf("allocuvm out of memory\n");
1942       deallocuvm(pgdir, newsz, oldsz);
1943       return 0;
1944     }
1945     memset(mem, 0, PGSIZE);
1946     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1947       cprintf("allocuvm out of memory (2)\n");
1948       deallocuvm(pgdir, newsz, oldsz);
1949       kfree(mem);
1950       return 0;
1951     }
1952   }
1953   return newsz;
1954 }
1955 
1956 
1957 
1958 
1959 
1960 int
1961 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1962 {
1963   pte_t *pte;
1964   uint a, pa;
1965 
1966   if(newsz >= oldsz)
1967     return oldsz;
1968 
1969   a = PGROUNDUP(newsz);
1970   for(; a  < oldsz; a += PGSIZE){
1971     pte = walkpgdir(pgdir, (char*)a, 0);
1972     if(!pte)
1973       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
1974     else if((*pte & PTE_P) != 0){
1975       pa = PTE_ADDR(*pte);
1976       if(pa == 0)
1977         panic("kfree");
1978       char *v = P2V(pa);
1979       kfree(v);
1980       *pte = 0;
1981     }
1982   }
1983   return newsz;
1984 }
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 
2002 void
2003 freevm(pde_t *pgdir)
2004 {
2005   uint i;
2006 
2007   if(pgdir == 0)
2008     panic("freevm: no pgdir");
2009   deallocuvm(pgdir, KERNBASE, 0);
2010   for(i = 0; i < NPDENTRIES; i++){
2011     if(pgdir[i] & PTE_P){
2012       char * v = P2V(PTE_ADDR(pgdir[i]));
2013       kfree(v);
2014     }
2015   }
2016   kfree((char*)pgdir);
2017 }
2018 
2019 
2020 
2021 void
2022 clearpteu(pde_t *pgdir, char *uva)
2023 {
2024   pte_t *pte;
2025 
2026   pte = walkpgdir(pgdir, uva, 0);
2027   if(pte == 0)
2028     panic("clearpteu");
2029   *pte &= ~PTE_U;
2030 }
2031 
2032 
2033 
2034 pde_t*
2035 copyuvm(pde_t *pgdir, uint sz)
2036 {
2037   pde_t *d;
2038   pte_t *pte;
2039   uint pa, i, flags;
2040   char *mem;
2041 
2042   if((d = setupkvm()) == 0)
2043     return 0;
2044   for(i = 0; i < sz; i += PGSIZE){
2045     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2046       panic("copyuvm: pte should exist");
2047     if(!(*pte & PTE_P))
2048       panic("copyuvm: page not present");
2049     pa = PTE_ADDR(*pte);
2050     flags = PTE_FLAGS(*pte);
2051     if((mem = kalloc()) == 0)
2052       goto bad;
2053     memmove(mem, (char*)P2V(pa), PGSIZE);
2054     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
2055       kfree(mem);
2056       goto bad;
2057     }
2058   }
2059   return d;
2060 
2061 bad:
2062   freevm(d);
2063   return 0;
2064 }
2065 
2066 
2067 
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 char*
2102 uva2ka(pde_t *pgdir, char *uva)
2103 {
2104   pte_t *pte;
2105 
2106   pte = walkpgdir(pgdir, uva, 0);
2107   if((*pte & PTE_P) == 0)
2108     return 0;
2109   if((*pte & PTE_U) == 0)
2110     return 0;
2111   return (char*)P2V(PTE_ADDR(*pte));
2112 }
2113 
2114 
2115 
2116 
2117 int
2118 copyout(pde_t *pgdir, uint va, void *p, uint len)
2119 {
2120   char *buf, *pa0;
2121   uint n, va0;
2122 
2123   buf = (char*)p;
2124   while(len > 0){
2125     va0 = (uint)PGROUNDDOWN(va);
2126     pa0 = uva2ka(pgdir, (char*)va0);
2127     if(pa0 == 0)
2128       return -1;
2129     n = PGSIZE - (va - va0);
2130     if(n > len)
2131       n = len;
2132     memmove(pa0 + (va - va0), buf, n);
2133     len -= n;
2134     buf += n;
2135     va = va0 + PGSIZE;
2136   }
2137   return 0;
2138 }
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 
2152 
2153 
2154 
2155 
2156 
2157 
2158 
2159 
2160 
2161 
2162 
2163 
2164 
2165 
2166 
2167 
2168 
2169 
2170 
2171 
2172 
2173 
2174 
2175 
2176 
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 struct cpu {
2302   uchar apicid;                
2303   struct context *scheduler;   
2304   struct taskstate ts;         
2305   struct segdesc gdt[NSEGS];   
2306   volatile uint started;       
2307   int ncli;                    
2308   int intena;                  
2309   struct proc *proc;           
2310 };
2311 
2312 extern struct cpu cpus[NCPU];
2313 extern int ncpu;
2314 
2315 
2316 
2317 
2318 
2319 
2320 
2321 
2322 
2323 
2324 
2325 
2326 struct context {
2327   uint edi;
2328   uint esi;
2329   uint ebx;
2330   uint ebp;
2331   uint eip;
2332 };
2333 
2334 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2335 
2336 
2337 struct proc {
2338   uint sz;                     
2339   pde_t* pgdir;                
2340   char *kstack;                
2341   enum procstate state;        
2342   int pid;                     
2343   struct proc *parent;         
2344   struct trapframe *tf;        
2345   struct context *context;     
2346   void *chan;                  
2347   int killed;                  
2348   struct file *ofile[NOFILE];  
2349   struct inode *cwd;           
2350   char name[16];               
2351 };
2352 
2353 
2354 
2355 
2356 
2357 
2358 
2359 
2360 
2361 
2362 
2363 
2364 
2365 
2366 
2367 
2368 
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 
2391 
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 #include "types.h"
2401 #include "defs.h"
2402 #include "param.h"
2403 #include "memlayout.h"
2404 #include "mmu.h"
2405 #include "x86.h"
2406 #include "proc.h"
2407 #include "spinlock.h"
2408 
2409 struct {
2410   struct spinlock lock;
2411   struct proc proc[NPROC];
2412 } ptable;
2413 
2414 static struct proc *initproc;
2415 
2416 int nextpid = 1;
2417 extern void forkret(void);
2418 extern void trapret(void);
2419 
2420 static void wakeup1(void *chan);
2421 
2422 int counter = 0;
2423 
2424 void
2425 pinit(void)
2426 {
2427   initlock(&ptable.lock, "ptable");
2428 }
2429 
2430 
2431 int
2432 cpuid() {
2433   return mycpu()-cpus;
2434 }
2435 
2436 
2437 
2438 
2439 
2440 
2441 
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 struct cpu*
2453 mycpu(void)
2454 {
2455   int apicid, i;
2456 
2457   if(readeflags()&FL_IF)
2458     panic("mycpu called with interrupts enabled\n");
2459 
2460   apicid = lapicid();
2461   
2462   
2463   for (i = 0; i < ncpu; ++i) {
2464     if (cpus[i].apicid == apicid)
2465       return &cpus[i];
2466   }
2467   panic("unknown apicid\n");
2468 }
2469 
2470 
2471 
2472 struct proc*
2473 myproc(void) {
2474   struct cpu *c;
2475   struct proc *p;
2476   pushcli();
2477   c = mycpu();
2478   p = c->proc;
2479   popcli();
2480   return p;
2481 }
2482 
2483 
2484 
2485 
2486 
2487 
2488 
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 
2503 
2504 static struct proc*
2505 allocproc(void)
2506 {
2507   struct proc *p;
2508   char *sp;
2509 
2510   acquire(&ptable.lock);
2511 
2512   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2513     if(p->state == UNUSED)
2514       goto found;
2515 
2516   release(&ptable.lock);
2517   return 0;
2518 
2519 found:
2520   p->state = EMBRYO;
2521   p->pid = nextpid++;
2522 
2523   release(&ptable.lock);
2524 
2525   
2526   if((p->kstack = kalloc()) == 0){
2527     p->state = UNUSED;
2528     return 0;
2529   }
2530   sp = p->kstack + KSTACKSIZE;
2531 
2532   
2533   sp -= sizeof *p->tf;
2534   p->tf = (struct trapframe*)sp;
2535 
2536   
2537   
2538   sp -= 4;
2539   *(uint*)sp = (uint)trapret;
2540 
2541   sp -= sizeof *p->context;
2542   p->context = (struct context*)sp;
2543   memset(p->context, 0, sizeof *p->context);
2544   p->context->eip = (uint)forkret;
2545 
2546   return p;
2547 }
2548 
2549 
2550 
2551 void
2552 userinit(void)
2553 {
2554   struct proc *p;
2555   extern char _binary_initcode_start[], _binary_initcode_size[];
2556 
2557   p = allocproc();
2558 
2559   initproc = p;
2560   if((p->pgdir = setupkvm()) == 0)
2561     panic("userinit: out of memory?");
2562   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2563   p->sz = PGSIZE;
2564   memset(p->tf, 0, sizeof(*p->tf));
2565   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2566   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2567   p->tf->es = p->tf->ds;
2568   p->tf->ss = p->tf->ds;
2569   p->tf->eflags = FL_IF;
2570   p->tf->esp = PGSIZE;
2571   p->tf->eip = 0;  
2572 
2573   safestrcpy(p->name, "initcode", sizeof(p->name));
2574   p->cwd = namei("/");
2575 
2576   
2577   
2578   
2579   
2580   acquire(&ptable.lock);
2581 
2582   p->state = RUNNABLE;
2583 
2584   release(&ptable.lock);
2585 }
2586 
2587 
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 int
2603 growproc(int n)
2604 {
2605   uint sz;
2606   struct proc *curproc = myproc();
2607 
2608   sz = curproc->sz;
2609   if(n > 0){
2610     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2611       return -1;
2612   } else if(n < 0){
2613     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2614       return -1;
2615   }
2616   curproc->sz = sz;
2617   switchuvm(curproc);
2618   return 0;
2619 }
2620 
2621 
2622 
2623 
2624 int
2625 fork(void)
2626 {
2627   int i, pid;
2628   struct proc *np;
2629   struct proc *curproc = myproc();
2630 
2631   
2632   if((np = allocproc()) == 0){
2633     return -1;
2634   }
2635 
2636   
2637   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2638     kfree(np->kstack);
2639     np->kstack = 0;
2640     np->state = UNUSED;
2641     return -1;
2642   }
2643   np->sz = curproc->sz;
2644   np->parent = curproc;
2645   *np->tf = *curproc->tf;
2646 
2647   
2648   np->tf->eax = 0;
2649 
2650   for(i = 0; i < NOFILE; i++)
2651     if(curproc->ofile[i])
2652       np->ofile[i] = filedup(curproc->ofile[i]);
2653   np->cwd = idup(curproc->cwd);
2654 
2655   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2656 
2657   pid = np->pid;
2658 
2659   acquire(&ptable.lock);
2660 
2661   np->state = RUNNABLE;
2662 
2663   release(&ptable.lock);
2664 
2665   return pid;
2666 }
2667 
2668 
2669 
2670 
2671 void
2672 exit(void)
2673 {
2674   struct proc *curproc = myproc();
2675   struct proc *p;
2676   int fd;
2677 
2678   if(curproc == initproc)
2679     panic("init exiting");
2680 
2681   
2682   for(fd = 0; fd < NOFILE; fd++){
2683     if(curproc->ofile[fd]){
2684       fileclose(curproc->ofile[fd]);
2685       curproc->ofile[fd] = 0;
2686     }
2687   }
2688 
2689   begin_op();
2690   iput(curproc->cwd);
2691   end_op();
2692   curproc->cwd = 0;
2693 
2694   acquire(&ptable.lock);
2695 
2696   
2697   wakeup1(curproc->parent);
2698 
2699 
2700   
2701   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2702     if(p->parent == curproc){
2703       p->parent = initproc;
2704       if(p->state == ZOMBIE)
2705         wakeup1(initproc);
2706     }
2707   }
2708 
2709   
2710   curproc->state = ZOMBIE;
2711   sched();
2712   panic("zombie exit");
2713 }
2714 
2715 
2716 
2717 int
2718 wait(void)
2719 {
2720   struct proc *p;
2721   int havekids, pid;
2722   struct proc *curproc = myproc();
2723 
2724   acquire(&ptable.lock);
2725   for(;;){
2726     
2727     havekids = 0;
2728     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2729       if(p->parent != curproc)
2730         continue;
2731       havekids = 1;
2732       if(p->state == ZOMBIE){
2733         
2734         pid = p->pid;
2735         kfree(p->kstack);
2736         p->kstack = 0;
2737         freevm(p->pgdir);
2738         p->pid = 0;
2739         p->parent = 0;
2740         p->name[0] = 0;
2741         p->killed = 0;
2742         p->state = UNUSED;
2743         release(&ptable.lock);
2744         return pid;
2745       }
2746     }
2747 
2748 
2749 
2750     
2751     if(!havekids || curproc->killed){
2752       release(&ptable.lock);
2753       return -1;
2754     }
2755 
2756     
2757     sleep(curproc, &ptable.lock);  
2758   }
2759 }
2760 
2761 
2762 
2763 
2764 
2765 
2766 
2767 
2768 
2769 
2770 
2771 
2772 
2773 
2774 
2775 
2776 
2777 
2778 
2779 
2780 
2781 
2782 
2783 
2784 
2785 
2786 
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 
2804 
2805 
2806 
2807 void
2808 scheduler(void)
2809 {
2810   struct proc *p;
2811   struct cpu *c = mycpu();
2812   c->proc = 0;
2813 
2814   for(;;){
2815     
2816     sti();
2817 
2818     
2819     acquire(&ptable.lock);
2820     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2821       if(p->state != RUNNABLE)
2822         continue;
2823 
2824       
2825       
2826       
2827       c->proc = p;
2828       switchuvm(p);
2829       p->state = RUNNING;
2830 
2831       swtch(&(c->scheduler), p->context);
2832       switchkvm();
2833 
2834       
2835       
2836       c->proc = 0;
2837     }
2838     release(&ptable.lock);
2839 
2840   }
2841 }
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 
2853 
2854 
2855 
2856 
2857 void
2858 sched(void)
2859 {
2860   int intena;
2861   struct proc *p = myproc();
2862 
2863   if(!holding(&ptable.lock))
2864     panic("sched ptable.lock");
2865   if(mycpu()->ncli != 1)
2866     panic("sched locks");
2867   if(p->state == RUNNING)
2868     panic("sched running");
2869   if(readeflags()&FL_IF)
2870     panic("sched interruptible");
2871   intena = mycpu()->intena;
2872   swtch(&p->context, mycpu()->scheduler);
2873   mycpu()->intena = intena;
2874 }
2875 
2876 
2877 void
2878 yield(void)
2879 {
2880   acquire(&ptable.lock);  
2881   myproc()->state = RUNNABLE;
2882   sched();
2883   release(&ptable.lock);
2884 }
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 void
2903 forkret(void)
2904 {
2905   static int first = 1;
2906   
2907   release(&ptable.lock);
2908 
2909   if (first) {
2910     
2911     
2912     
2913     first = 0;
2914     iinit(ROOTDEV);
2915     initlog(ROOTDEV);
2916   }
2917 
2918   
2919 }
2920 
2921 
2922 
2923 void
2924 sleep(void *chan, struct spinlock *lk)
2925 {
2926   struct proc *p = myproc();
2927 
2928   if(p == 0)
2929     panic("sleep");
2930 
2931   if(lk == 0)
2932     panic("sleep without lk");
2933 
2934   
2935   
2936   
2937   
2938   
2939   
2940   if(lk != &ptable.lock){  
2941     acquire(&ptable.lock);  
2942     release(lk);
2943   }
2944   
2945   p->chan = chan;
2946   p->state = SLEEPING;
2947 
2948   sched();
2949 
2950   
2951   p->chan = 0;
2952 
2953   
2954   if(lk != &ptable.lock){  
2955     release(&ptable.lock);
2956     acquire(lk);
2957   }
2958 }
2959 
2960 
2961 
2962 
2963 
2964 
2965 
2966 
2967 
2968 
2969 
2970 
2971 
2972 
2973 
2974 
2975 
2976 
2977 
2978 
2979 
2980 
2981 
2982 
2983 
2984 
2985 
2986 
2987 
2988 
2989 
2990 
2991 
2992 
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 static void
3003 wakeup1(void *chan)
3004 {
3005   struct proc *p;
3006 
3007   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3008     if(p->state == SLEEPING && p->chan == chan)
3009       p->state = RUNNABLE;
3010 }
3011 
3012 
3013 void
3014 wakeup(void *chan)
3015 {
3016   acquire(&ptable.lock);
3017   wakeup1(chan);
3018   release(&ptable.lock);
3019 }
3020 
3021 
3022 
3023 
3024 int
3025 kill(int pid)
3026 {
3027   struct proc *p;
3028 
3029   acquire(&ptable.lock);
3030   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3031     if(p->pid == pid){
3032       p->killed = 1;
3033       
3034       if(p->state == SLEEPING)
3035         p->state = RUNNABLE;
3036       release(&ptable.lock);
3037       return 0;
3038     }
3039   }
3040   release(&ptable.lock);
3041   return -1;
3042 }
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053 void
3054 procdump(void)
3055 {
3056   static char *states[] = {
3057   [UNUSED]    "unused",
3058   [EMBRYO]    "embryo",
3059   [SLEEPING]  "sleep ",
3060   [RUNNABLE]  "runble",
3061   [RUNNING]   "run   ",
3062   [ZOMBIE]    "zombie"
3063   };
3064   int i;
3065   struct proc *p;
3066   char *state;
3067   uint pc[10];
3068 
3069   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3070     if(p->state == UNUSED)
3071       continue;
3072     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3073       state = states[p->state];
3074     else
3075       state = "???";
3076     cprintf("%d %s %s", p->pid, state, p->name);
3077     if(p->state == SLEEPING){
3078       getcallerpcs((uint*)p->context->ebp+2, pc);
3079       for(i=0; i<10 && pc[i] != 0; i++)
3080         cprintf(" %p", pc[i]);
3081     }
3082     cprintf("\n");
3083   }
3084 }
3085 
3086 int getreadcount(void){
3087   return counter;
3088 }
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 
3101 
3102 
3103 
3104 
3105 
3106 
3107 
3108 .globl swtch
3109 swtch:
3110   movl 4(%esp), %eax
3111   movl 8(%esp), %edx
3112 
3113   
3114   pushl %ebp
3115   pushl %ebx
3116   pushl %esi
3117   pushl %edi
3118 
3119   
3120   movl %esp, (%eax)
3121   movl %edx, %esp
3122 
3123   
3124   popl %edi
3125   popl %esi
3126   popl %ebx
3127   popl %ebp
3128   ret
3129 
3130 
3131 
3132 
3133 
3134 
3135 
3136 
3137 
3138 
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 
3151 
3152 
3153 
3154 #include "types.h"
3155 #include "defs.h"
3156 #include "param.h"
3157 #include "memlayout.h"
3158 #include "mmu.h"
3159 #include "spinlock.h"
3160 
3161 void freerange(void *vstart, void *vend);
3162 extern char end[]; 
3163                    
3164 
3165 struct run {
3166   struct run *next;
3167 };
3168 
3169 struct {
3170   struct spinlock lock;
3171   int use_lock;
3172   struct run *freelist;
3173 } kmem;
3174 
3175 
3176 
3177 
3178 
3179 
3180 void
3181 kinit1(void *vstart, void *vend)
3182 {
3183   initlock(&kmem.lock, "kmem");
3184   kmem.use_lock = 0;
3185   freerange(vstart, vend);
3186 }
3187 
3188 void
3189 kinit2(void *vstart, void *vend)
3190 {
3191   freerange(vstart, vend);
3192   kmem.use_lock = 1;
3193 }
3194 
3195 
3196 
3197 
3198 
3199 
3200 void
3201 freerange(void *vstart, void *vend)
3202 {
3203   char *p;
3204   p = (char*)PGROUNDUP((uint)vstart);
3205   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3206     kfree(p);
3207 }
3208 
3209 
3210 
3211 
3212 
3213 void
3214 kfree(char *v)
3215 {
3216   struct run *r;
3217 
3218   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3219     panic("kfree");
3220 
3221   
3222   memset(v, 1, PGSIZE);
3223 
3224   if(kmem.use_lock)
3225     acquire(&kmem.lock);
3226   r = (struct run*)v;
3227   r->next = kmem.freelist;
3228   kmem.freelist = r;
3229   if(kmem.use_lock)
3230     release(&kmem.lock);
3231 }
3232 
3233 
3234 
3235 
3236 char*
3237 kalloc(void)
3238 {
3239   struct run *r;
3240 
3241   if(kmem.use_lock)
3242     acquire(&kmem.lock);
3243   r = kmem.freelist;
3244   if(r)
3245     kmem.freelist = r->next;
3246   if(kmem.use_lock)
3247     release(&kmem.lock);
3248   return (char*)r;
3249 }
3250 
3251 
3252 
3253 #define T_DIVIDE         0      
3254 #define T_DEBUG          1      
3255 #define T_NMI            2      
3256 #define T_BRKPT          3      
3257 #define T_OFLOW          4      
3258 #define T_BOUND          5      
3259 #define T_ILLOP          6      
3260 #define T_DEVICE         7      
3261 #define T_DBLFLT         8      
3262 
3263 #define T_TSS           10      
3264 #define T_SEGNP         11      
3265 #define T_STACK         12      
3266 #define T_GPFLT         13      
3267 #define T_PGFLT         14      
3268 
3269 #define T_FPERR         16      
3270 #define T_ALIGN         17      
3271 #define T_MCHK          18      
3272 #define T_SIMDERR       19      
3273 
3274 
3275 
3276 #define T_SYSCALL       64      
3277 #define T_DEFAULT      500      
3278 
3279 #define T_IRQ0          32      
3280 
3281 #define IRQ_TIMER        0
3282 #define IRQ_KBD          1
3283 #define IRQ_COM1         4
3284 #define IRQ_IDE         14
3285 #define IRQ_ERROR       19
3286 #define IRQ_SPURIOUS    31
3287 
3288 
3289 
3290 
3291 
3292 
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 #!/usr/bin/perl -w
3301 
3302 # Generate vectors.S, the trap/interrupt entry points.
3303 # There has to be one entry point per interrupt number
3304 # since otherwise there's no way for trap() to discover
3305 # the interrupt number.
3306 
3307 print "# generated by vectors.pl - do not edit\n";
3308 print "# handlers\n";
3309 print ".globl alltraps\n";
3310 for(my $i = 0; $i < 256; $i++){
3311     print ".globl vector$i\n";
3312     print "vector$i:\n";
3313     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3314         print "  pushl \$0\n";
3315     }
3316     print "  pushl \$$i\n";
3317     print "  jmp alltraps\n";
3318 }
3319 
3320 print "\n# vector table\n";
3321 print ".data\n";
3322 print ".globl vectors\n";
3323 print "vectors:\n";
3324 for(my $i = 0; $i < 256; $i++){
3325     print "  .long vector$i\n";
3326 }
3327 
3328 # sample output:
3329 #   # handlers
3330 #   .globl alltraps
3331 #   .globl vector0
3332 #   vector0:
3333 #     pushl $0
3334 #     pushl $0
3335 #     jmp alltraps
3336 #   ...
3337 #
3338 #   # vector table
3339 #   .data
3340 #   .globl vectors
3341 #   vectors:
3342 #     .long vector0
3343 #     .long vector1
3344 #     .long vector2
3345 #   ...
3346 
3347 
3348 
3349 
3350 
3351 
3352   
3353 .globl alltraps
3354 alltraps:
3355   
3356   pushl %ds
3357   pushl %es
3358   pushl %fs
3359   pushl %gs
3360   pushal
3361 
3362   
3363   movw $(SEG_KDATA<<3), %ax
3364   movw %ax, %ds
3365   movw %ax, %es
3366 
3367   
3368   pushl %esp
3369   call trap
3370   addl $4, %esp
3371 
3372   
3373 .globl trapret
3374 trapret:
3375   popal
3376   popl %gs
3377   popl %fs
3378   popl %es
3379   popl %ds
3380   addl $0x8, %esp  
3381   iret
3382 
3383 
3384 
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 #include "types.h"
3401 #include "defs.h"
3402 #include "param.h"
3403 #include "memlayout.h"
3404 #include "mmu.h"
3405 #include "proc.h"
3406 #include "x86.h"
3407 #include "traps.h"
3408 #include "spinlock.h"
3409 
3410 
3411 struct gatedesc idt[256];
3412 extern uint vectors[];  
3413 struct spinlock tickslock;
3414 uint ticks;
3415 
3416 void
3417 tvinit(void)
3418 {
3419   int i;
3420 
3421   for(i = 0; i < 256; i++)
3422     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3423   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3424 
3425   initlock(&tickslock, "time");
3426 }
3427 
3428 void
3429 idtinit(void)
3430 {
3431   lidt(idt, sizeof(idt));
3432 }
3433 
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 void
3451 trap(struct trapframe *tf)
3452 {
3453   if(tf->trapno == T_SYSCALL){
3454     if(myproc()->killed)
3455       exit();
3456     myproc()->tf = tf;
3457     syscall();
3458     if(myproc()->killed)
3459       exit();
3460     return;
3461   }
3462 
3463   switch(tf->trapno){
3464   case T_IRQ0 + IRQ_TIMER:
3465     if(cpuid() == 0){
3466       acquire(&tickslock);
3467       ticks++;
3468       wakeup(&ticks);
3469       release(&tickslock);
3470     }
3471     lapiceoi();
3472     break;
3473   case T_IRQ0 + IRQ_IDE:
3474     ideintr();
3475     lapiceoi();
3476     break;
3477   case T_IRQ0 + IRQ_IDE+1:
3478     
3479     break;
3480   case T_IRQ0 + IRQ_KBD:
3481     kbdintr();
3482     lapiceoi();
3483     break;
3484   case T_IRQ0 + IRQ_COM1:
3485     uartintr();
3486     lapiceoi();
3487     break;
3488   case T_IRQ0 + 7:
3489   case T_IRQ0 + IRQ_SPURIOUS:
3490     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3491             cpuid(), tf->cs, tf->eip);
3492     lapiceoi();
3493     break;
3494 
3495 
3496 
3497 
3498 
3499 
3500   default:
3501     if(myproc() == 0 || (tf->cs&3) == 0){
3502       
3503       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3504               tf->trapno, cpuid(), tf->eip, rcr2());
3505       panic("trap");
3506     }
3507     
3508     cprintf("pid %d %s: trap %d err %d on cpu %d "
3509             "eip 0x%x addr 0x%x--kill proc\n",
3510             myproc()->pid, myproc()->name, tf->trapno,
3511             tf->err, cpuid(), tf->eip, rcr2());
3512     myproc()->killed = 1;
3513   }
3514 
3515   
3516   
3517   
3518   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3519     exit();
3520 
3521   
3522   
3523   if(myproc() && myproc()->state == RUNNING &&
3524      tf->trapno == T_IRQ0+IRQ_TIMER)
3525     yield();
3526 
3527   
3528   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3529     exit();
3530 }
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 
3551 #define SYS_fork    1
3552 #define SYS_exit    2
3553 #define SYS_wait    3
3554 #define SYS_pipe    4
3555 #define SYS_read    5
3556 #define SYS_kill    6
3557 #define SYS_exec    7
3558 #define SYS_fstat   8
3559 #define SYS_chdir   9
3560 #define SYS_dup    10
3561 #define SYS_getpid 11
3562 #define SYS_sbrk   12
3563 #define SYS_sleep  13
3564 #define SYS_uptime 14
3565 #define SYS_open   15
3566 #define SYS_write  16
3567 #define SYS_mknod  17
3568 #define SYS_unlink 18
3569 #define SYS_link   19
3570 #define SYS_mkdir  20
3571 #define SYS_close  21
3572 #define SYS_getreadcount 22
3573 
3574 
3575 
3576 
3577 
3578 
3579 
3580 
3581 
3582 
3583 
3584 
3585 
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 #include "types.h"
3601 #include "defs.h"
3602 #include "param.h"
3603 #include "memlayout.h"
3604 #include "mmu.h"
3605 #include "proc.h"
3606 #include "x86.h"
3607 #include "syscall.h"
3608 #include "spinlock.h"
3609 
3610 
3611 
3612 
3613 
3614 
3615 
3616 
3617 int
3618 fetchint(uint addr, int *ip)
3619 {
3620   struct proc *curproc = myproc();
3621 
3622   if(addr >= curproc->sz || addr+4 > curproc->sz)
3623     return -1;
3624   *ip = *(int*)(addr);
3625   return 0;
3626 }
3627 
3628 
3629 
3630 
3631 int
3632 fetchstr(uint addr, char **pp)
3633 {
3634   char *s, *ep;
3635   struct proc *curproc = myproc();
3636 
3637   if(addr >= curproc->sz)
3638     return -1;
3639   *pp = (char*)addr;
3640   ep = (char*)curproc->sz;
3641   for(s = *pp; s < ep; s++){
3642     if(*s == 0)
3643       return s - *pp;
3644   }
3645   return -1;
3646 }
3647 
3648 
3649 
3650 
3651 int
3652 argint(int n, int *ip)
3653 {
3654   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3655 }
3656 
3657 
3658 
3659 
3660 int
3661 argptr(int n, char **pp, int size)
3662 {
3663   int i;
3664   struct proc *curproc = myproc();
3665 
3666   if(argint(n, &i) < 0)
3667     return -1;
3668   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3669     return -1;
3670   *pp = (char*)i;
3671   return 0;
3672 }
3673 
3674 
3675 
3676 
3677 
3678 int
3679 argstr(int n, char **pp)
3680 {
3681   int addr;
3682   if(argint(n, &addr) < 0)
3683     return -1;
3684   return fetchstr(addr, pp);
3685 }
3686 
3687 
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 extern int sys_chdir(void);
3701 extern int sys_close(void);
3702 extern int sys_dup(void);
3703 extern int sys_exec(void);
3704 extern int sys_exit(void);
3705 extern int sys_fork(void);
3706 extern int sys_fstat(void);
3707 extern int sys_getpid(void);
3708 extern int sys_kill(void);
3709 extern int sys_link(void);
3710 extern int sys_mkdir(void);
3711 extern int sys_mknod(void);
3712 extern int sys_open(void);
3713 extern int sys_pipe(void);
3714 extern int sys_read(void);
3715 extern int sys_sbrk(void);
3716 extern int sys_sleep(void);
3717 extern int sys_unlink(void);
3718 extern int sys_wait(void);
3719 extern int sys_write(void);
3720 extern int sys_uptime(void);
3721 extern int sys_getreadcount(void);
3722 
3723 extern int counter;
3724 
3725 static int (*syscalls[])(void) = {
3726 [SYS_fork]    sys_fork,
3727 [SYS_exit]    sys_exit,
3728 [SYS_wait]    sys_wait,
3729 [SYS_pipe]    sys_pipe,
3730 [SYS_read]    sys_read,
3731 [SYS_kill]    sys_kill,
3732 [SYS_exec]    sys_exec,
3733 [SYS_fstat]   sys_fstat,
3734 [SYS_chdir]   sys_chdir,
3735 [SYS_dup]     sys_dup,
3736 [SYS_getpid]  sys_getpid,
3737 [SYS_sbrk]    sys_sbrk,
3738 [SYS_sleep]   sys_sleep,
3739 [SYS_uptime]  sys_uptime,
3740 [SYS_open]    sys_open,
3741 [SYS_write]   sys_write,
3742 [SYS_mknod]   sys_mknod,
3743 [SYS_unlink]  sys_unlink,
3744 [SYS_link]    sys_link,
3745 [SYS_mkdir]   sys_mkdir,
3746 [SYS_close]   sys_close,
3747 [SYS_getreadcount]  sys_getreadcount
3748 };
3749 
3750 struct spinlock lock;
3751 void
3752 syscall(void)
3753 {
3754   int num;
3755   struct proc *curproc = myproc();
3756 
3757   num = curproc->tf->eax;
3758   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3759     curproc->tf->eax = syscalls[num]();
3760     if(num==5){
3761       acquire(&lock);
3762       counter++;
3763       release(&lock);
3764     }
3765 
3766   } else {
3767     cprintf("%d %s: unknown sys call %d\n",
3768             curproc->pid, curproc->name, num);
3769     curproc->tf->eax = -1;
3770   }
3771 }
3772 
3773 
3774 
3775 
3776 
3777 
3778 
3779 
3780 
3781 
3782 
3783 
3784 
3785 
3786 
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 #include "types.h"
3801 #include "x86.h"
3802 #include "defs.h"
3803 #include "date.h"
3804 #include "param.h"
3805 #include "memlayout.h"
3806 #include "mmu.h"
3807 #include "proc.h"
3808 
3809 int
3810 sys_fork(void)
3811 {
3812   return fork();
3813 }
3814 
3815 int
3816 sys_exit(void)
3817 {
3818   exit();
3819   return 0;  
3820 }
3821 
3822 int
3823 sys_wait(void)
3824 {
3825   return wait();
3826 }
3827 
3828 int
3829 sys_kill(void)
3830 {
3831   int pid;
3832 
3833   if(argint(0, &pid) < 0)
3834     return -1;
3835   return kill(pid);
3836 }
3837 
3838 int
3839 sys_getpid(void)
3840 {
3841   return myproc()->pid;
3842 }
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 int
3851 sys_sbrk(void)
3852 {
3853   int addr;
3854   int n;
3855 
3856   if(argint(0, &n) < 0)
3857     return -1;
3858   addr = myproc()->sz;
3859   if(growproc(n) < 0)
3860     return -1;
3861   return addr;
3862 }
3863 
3864 int
3865 sys_sleep(void)
3866 {
3867   int n;
3868   uint ticks0;
3869 
3870   if(argint(0, &n) < 0)
3871     return -1;
3872   acquire(&tickslock);
3873   ticks0 = ticks;
3874   while(ticks - ticks0 < n){
3875     if(myproc()->killed){
3876       release(&tickslock);
3877       return -1;
3878     }
3879     sleep(&ticks, &tickslock);
3880   }
3881   release(&tickslock);
3882   return 0;
3883 }
3884 
3885 
3886 
3887 int
3888 sys_uptime(void)
3889 {
3890   uint xticks;
3891 
3892   acquire(&tickslock);
3893   xticks = ticks;
3894   release(&tickslock);
3895   return xticks;
3896 }
3897 
3898 
3899 
3900 int
3901 sys_getreadcount(void){
3902   return getreadcount();
3903 }
3904 
3905 
3906 
3907 
3908 
3909 
3910 
3911 
3912 
3913 
3914 
3915 
3916 
3917 
3918 
3919 
3920 
3921 
3922 
3923 
3924 
3925 
3926 
3927 
3928 
3929 
3930 
3931 
3932 
3933 
3934 
3935 
3936 
3937 
3938 
3939 
3940 
3941 
3942 
3943 
3944 
3945 
3946 
3947 
3948 
3949 
3950 struct buf {
3951   int flags;
3952   uint dev;
3953   uint blockno;
3954   struct sleeplock lock;
3955   uint refcnt;
3956   struct buf *prev; 
3957   struct buf *next;
3958   struct buf *qnext; 
3959   uchar data[BSIZE];
3960 };
3961 #define B_VALID 0x2  
3962 #define B_DIRTY 0x4  
3963 
3964 
3965 
3966 
3967 
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 struct sleeplock {
4002   uint locked;       
4003   struct spinlock lk; 
4004 
4005   
4006   char *name;        
4007   int pid;           
4008 };
4009 
4010 
4011 
4012 
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 #define O_RDONLY  0x000
4051 #define O_WRONLY  0x001
4052 #define O_RDWR    0x002
4053 #define O_CREATE  0x200
4054 
4055 
4056 
4057 
4058 
4059 
4060 
4061 
4062 
4063 
4064 
4065 
4066 
4067 
4068 
4069 
4070 
4071 
4072 
4073 
4074 
4075 
4076 
4077 
4078 
4079 
4080 
4081 
4082 
4083 
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 #define T_DIR  1   
4101 #define T_FILE 2   
4102 #define T_DEV  3   
4103 
4104 struct stat {
4105   short type;  
4106   int dev;     
4107   uint ino;    
4108   short nlink; 
4109   uint size;   
4110 };
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 
4152 
4153 
4154 #define ROOTINO 1  
4155 #define BSIZE 512  
4156 
4157 
4158 
4159 
4160 
4161 
4162 
4163 struct superblock {
4164   uint size;         
4165   uint nblocks;      
4166   uint ninodes;      
4167   uint nlog;         
4168   uint logstart;     
4169   uint inodestart;   
4170   uint bmapstart;    
4171 };
4172 
4173 #define NDIRECT 12
4174 #define NINDIRECT (BSIZE / sizeof(uint))
4175 #define MAXFILE (NDIRECT + NINDIRECT)
4176 
4177 
4178 struct dinode {
4179   short type;           
4180   short major;          
4181   short minor;          
4182   short nlink;          
4183   uint size;            
4184   uint addrs[NDIRECT+1];   
4185 };
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 
4201 #define IPB           (BSIZE / sizeof(struct dinode))
4202 
4203 
4204 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4205 
4206 
4207 #define BPB           (BSIZE*8)
4208 
4209 
4210 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4211 
4212 
4213 #define DIRSIZ 14
4214 
4215 struct dirent {
4216   ushort inum;
4217   char name[DIRSIZ];
4218 };
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 struct file {
4251   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4252   int ref; 
4253   char readable;
4254   char writable;
4255   struct pipe *pipe;
4256   struct inode *ip;
4257   uint off;
4258 };
4259 
4260 
4261 
4262 struct inode {
4263   uint dev;           
4264   uint inum;          
4265   int ref;            
4266   struct sleeplock lock; 
4267   int valid;          
4268 
4269   short type;         
4270   short major;
4271   short minor;
4272   short nlink;
4273   uint size;
4274   uint addrs[NDIRECT+1];
4275 };
4276 
4277 
4278 
4279 struct devsw {
4280   int (*read)(struct inode*, char*, int);
4281   int (*write)(struct inode*, char*, int);
4282 };
4283 
4284 extern struct devsw devsw[];
4285 
4286 #define CONSOLE 1
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 #include "types.h"
4303 #include "defs.h"
4304 #include "param.h"
4305 #include "memlayout.h"
4306 #include "mmu.h"
4307 #include "proc.h"
4308 #include "x86.h"
4309 #include "traps.h"
4310 #include "spinlock.h"
4311 #include "sleeplock.h"
4312 #include "fs.h"
4313 #include "buf.h"
4314 
4315 #define SECTOR_SIZE   512
4316 #define IDE_BSY       0x80
4317 #define IDE_DRDY      0x40
4318 #define IDE_DF        0x20
4319 #define IDE_ERR       0x01
4320 
4321 #define IDE_CMD_READ  0x20
4322 #define IDE_CMD_WRITE 0x30
4323 #define IDE_CMD_RDMUL 0xc4
4324 #define IDE_CMD_WRMUL 0xc5
4325 
4326 
4327 
4328 
4329 
4330 static struct spinlock idelock;
4331 static struct buf *idequeue;
4332 
4333 static int havedisk1;
4334 static void idestart(struct buf*);
4335 
4336 
4337 static int
4338 idewait(int checkerr)
4339 {
4340   int r;
4341 
4342   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4343     ;
4344   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4345     return -1;
4346   return 0;
4347 }
4348 
4349 
4350 void
4351 ideinit(void)
4352 {
4353   int i;
4354 
4355   initlock(&idelock, "ide");
4356   ioapicenable(IRQ_IDE, ncpu - 1);
4357   idewait(0);
4358 
4359   
4360   outb(0x1f6, 0xe0 | (1<<4));
4361   for(i=0; i<1000; i++){
4362     if(inb(0x1f7) != 0){
4363       havedisk1 = 1;
4364       break;
4365     }
4366   }
4367 
4368   
4369   outb(0x1f6, 0xe0 | (0<<4));
4370 }
4371 
4372 
4373 static void
4374 idestart(struct buf *b)
4375 {
4376   if(b == 0)
4377     panic("idestart");
4378   if(b->blockno >= FSSIZE)
4379     panic("incorrect blockno");
4380   int sector_per_block =  BSIZE/SECTOR_SIZE;
4381   int sector = b->blockno * sector_per_block;
4382   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4383   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4384 
4385   if (sector_per_block > 7) panic("idestart");
4386 
4387   idewait(0);
4388   outb(0x3f6, 0);  
4389   outb(0x1f2, sector_per_block);  
4390   outb(0x1f3, sector & 0xff);
4391   outb(0x1f4, (sector >> 8) & 0xff);
4392   outb(0x1f5, (sector >> 16) & 0xff);
4393   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4394   if(b->flags & B_DIRTY){
4395     outb(0x1f7, write_cmd);
4396     outsl(0x1f0, b->data, BSIZE/4);
4397   } else {
4398     outb(0x1f7, read_cmd);
4399   }
4400 }
4401 
4402 
4403 void
4404 ideintr(void)
4405 {
4406   struct buf *b;
4407 
4408   
4409   acquire(&idelock);
4410 
4411   if((b = idequeue) == 0){
4412     release(&idelock);
4413     return;
4414   }
4415   idequeue = b->qnext;
4416 
4417   
4418   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4419     insl(0x1f0, b->data, BSIZE/4);
4420 
4421   
4422   b->flags |= B_VALID;
4423   b->flags &= ~B_DIRTY;
4424   wakeup(b);
4425 
4426   
4427   if(idequeue != 0)
4428     idestart(idequeue);
4429 
4430   release(&idelock);
4431 }
4432 
4433 
4434 
4435 
4436 
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 
4452 
4453 void
4454 iderw(struct buf *b)
4455 {
4456   struct buf **pp;
4457 
4458   if(!holdingsleep(&b->lock))
4459     panic("iderw: buf not locked");
4460   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4461     panic("iderw: nothing to do");
4462   if(b->dev != 0 && !havedisk1)
4463     panic("iderw: ide disk 1 not present");
4464 
4465   acquire(&idelock);  
4466 
4467   
4468   b->qnext = 0;
4469   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4470     ;
4471   *pp = b;
4472 
4473   
4474   if(idequeue == b)
4475     idestart(b);
4476 
4477   
4478   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4479     sleep(b, &idelock);
4480   }
4481 
4482 
4483   release(&idelock);
4484 }
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 
4504 
4505 
4506 
4507 
4508 
4509 
4510 
4511 
4512 
4513 
4514 
4515 
4516 
4517 
4518 
4519 
4520 #include "types.h"
4521 #include "defs.h"
4522 #include "param.h"
4523 #include "spinlock.h"
4524 #include "sleeplock.h"
4525 #include "fs.h"
4526 #include "buf.h"
4527 
4528 struct {
4529   struct spinlock lock;
4530   struct buf buf[NBUF];
4531 
4532   
4533   
4534   struct buf head;
4535 } bcache;
4536 
4537 void
4538 binit(void)
4539 {
4540   struct buf *b;
4541 
4542   initlock(&bcache.lock, "bcache");
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550   
4551   bcache.head.prev = &bcache.head;
4552   bcache.head.next = &bcache.head;
4553   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4554     b->next = bcache.head.next;
4555     b->prev = &bcache.head;
4556     initsleeplock(&b->lock, "buffer");
4557     bcache.head.next->prev = b;
4558     bcache.head.next = b;
4559   }
4560 }
4561 
4562 
4563 
4564 
4565 static struct buf*
4566 bget(uint dev, uint blockno)
4567 {
4568   struct buf *b;
4569 
4570   acquire(&bcache.lock);
4571 
4572   
4573   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4574     if(b->dev == dev && b->blockno == blockno){
4575       b->refcnt++;
4576       release(&bcache.lock);
4577       acquiresleep(&b->lock);
4578       return b;
4579     }
4580   }
4581 
4582   
4583   
4584   
4585   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4586     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4587       b->dev = dev;
4588       b->blockno = blockno;
4589       b->flags = 0;
4590       b->refcnt = 1;
4591       release(&bcache.lock);
4592       acquiresleep(&b->lock);
4593       return b;
4594     }
4595   }
4596   panic("bget: no buffers");
4597 }
4598 
4599 
4600 
4601 struct buf*
4602 bread(uint dev, uint blockno)
4603 {
4604   struct buf *b;
4605 
4606   b = bget(dev, blockno);
4607   if((b->flags & B_VALID) == 0) {
4608     iderw(b);
4609   }
4610   return b;
4611 }
4612 
4613 
4614 void
4615 bwrite(struct buf *b)
4616 {
4617   if(!holdingsleep(&b->lock))
4618     panic("bwrite");
4619   b->flags |= B_DIRTY;
4620   iderw(b);
4621 }
4622 
4623 
4624 
4625 void
4626 brelse(struct buf *b)
4627 {
4628   if(!holdingsleep(&b->lock))
4629     panic("brelse");
4630 
4631   releasesleep(&b->lock);
4632 
4633   acquire(&bcache.lock);
4634   b->refcnt--;
4635   if (b->refcnt == 0) {
4636     
4637     b->next->prev = b->prev;
4638     b->prev->next = b->next;
4639     b->next = bcache.head.next;
4640     b->prev = &bcache.head;
4641     bcache.head.next->prev = b;
4642     bcache.head.next = b;
4643   }
4644 
4645   release(&bcache.lock);
4646 }
4647 
4648 
4649 
4650 
4651 
4652 
4653 
4654 
4655 
4656 
4657 
4658 
4659 
4660 
4661 
4662 
4663 
4664 
4665 
4666 
4667 
4668 
4669 
4670 
4671 
4672 
4673 
4674 
4675 
4676 
4677 
4678 
4679 
4680 
4681 
4682 
4683 
4684 
4685 
4686 
4687 
4688 
4689 
4690 
4691 
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 
4701 
4702 #include "types.h"
4703 #include "defs.h"
4704 #include "param.h"
4705 #include "x86.h"
4706 #include "memlayout.h"
4707 #include "mmu.h"
4708 #include "proc.h"
4709 #include "spinlock.h"
4710 #include "sleeplock.h"
4711 
4712 void
4713 initsleeplock(struct sleeplock *lk, char *name)
4714 {
4715   initlock(&lk->lk, "sleep lock");
4716   lk->name = name;
4717   lk->locked = 0;
4718   lk->pid = 0;
4719 }
4720 
4721 void
4722 acquiresleep(struct sleeplock *lk)
4723 {
4724   acquire(&lk->lk);
4725   while (lk->locked) {
4726     sleep(lk, &lk->lk);
4727   }
4728   lk->locked = 1;
4729   lk->pid = myproc()->pid;
4730   release(&lk->lk);
4731 }
4732 
4733 void
4734 releasesleep(struct sleeplock *lk)
4735 {
4736   acquire(&lk->lk);
4737   lk->locked = 0;
4738   lk->pid = 0;
4739   wakeup(lk);
4740   release(&lk->lk);
4741 }
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 int
4751 holdingsleep(struct sleeplock *lk)
4752 {
4753   int r;
4754 
4755   acquire(&lk->lk);
4756   r = lk->locked && (lk->pid == myproc()->pid);
4757   release(&lk->lk);
4758   return r;
4759 }
4760 
4761 
4762 
4763 
4764 
4765 
4766 
4767 
4768 
4769 
4770 
4771 
4772 
4773 
4774 
4775 
4776 
4777 
4778 
4779 
4780 
4781 
4782 
4783 
4784 
4785 
4786 
4787 
4788 
4789 
4790 
4791 
4792 
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800 #include "types.h"
4801 #include "defs.h"
4802 #include "param.h"
4803 #include "spinlock.h"
4804 #include "sleeplock.h"
4805 #include "fs.h"
4806 #include "buf.h"
4807 
4808 
4809 
4810 
4811 
4812 
4813 
4814 
4815 
4816 
4817 
4818 
4819 
4820 
4821 
4822 
4823 
4824 
4825 
4826 
4827 
4828 
4829 
4830 
4831 
4832 
4833 struct logheader {
4834   int n;
4835   int block[LOGSIZE];
4836 };
4837 
4838 struct log {
4839   struct spinlock lock;
4840   int start;
4841   int size;
4842   int outstanding; 
4843   int committing;  
4844   int dev;
4845   struct logheader lh;
4846 };
4847 
4848 
4849 
4850 struct log log;
4851 
4852 static void recover_from_log(void);
4853 static void commit();
4854 
4855 void
4856 initlog(int dev)
4857 {
4858   if (sizeof(struct logheader) >= BSIZE)
4859     panic("initlog: too big logheader");
4860 
4861   struct superblock sb;
4862   initlock(&log.lock, "log");
4863   readsb(dev, &sb);
4864   log.start = sb.logstart;
4865   log.size = sb.nlog;
4866   log.dev = dev;
4867   recover_from_log();
4868 }
4869 
4870 
4871 static void
4872 install_trans(void)
4873 {
4874   int tail;
4875 
4876   for (tail = 0; tail < log.lh.n; tail++) {
4877     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4878     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4879     memmove(dbuf->data, lbuf->data, BSIZE);  
4880     bwrite(dbuf);  
4881     brelse(lbuf);
4882     brelse(dbuf);
4883   }
4884 }
4885 
4886 
4887 static void
4888 read_head(void)
4889 {
4890   struct buf *buf = bread(log.dev, log.start);
4891   struct logheader *lh = (struct logheader *) (buf->data);
4892   int i;
4893   log.lh.n = lh->n;
4894   for (i = 0; i < log.lh.n; i++) {
4895     log.lh.block[i] = lh->block[i];
4896   }
4897   brelse(buf);
4898 }
4899 
4900 
4901 
4902 
4903 static void
4904 write_head(void)
4905 {
4906   struct buf *buf = bread(log.dev, log.start);
4907   struct logheader *hb = (struct logheader *) (buf->data);
4908   int i;
4909   hb->n = log.lh.n;
4910   for (i = 0; i < log.lh.n; i++) {
4911     hb->block[i] = log.lh.block[i];
4912   }
4913   bwrite(buf);
4914   brelse(buf);
4915 }
4916 
4917 static void
4918 recover_from_log(void)
4919 {
4920   read_head();
4921   install_trans(); 
4922   log.lh.n = 0;
4923   write_head(); 
4924 }
4925 
4926 
4927 void
4928 begin_op(void)
4929 {
4930   acquire(&log.lock);
4931   while(1){
4932     if(log.committing){
4933       sleep(&log, &log.lock);
4934     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4935       
4936       sleep(&log, &log.lock);
4937     } else {
4938       log.outstanding += 1;
4939       release(&log.lock);
4940       break;
4941     }
4942   }
4943 }
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 void
4953 end_op(void)
4954 {
4955   int do_commit = 0;
4956 
4957   acquire(&log.lock);
4958   log.outstanding -= 1;
4959   if(log.committing)
4960     panic("log.committing");
4961   if(log.outstanding == 0){
4962     do_commit = 1;
4963     log.committing = 1;
4964   } else {
4965     
4966     
4967     
4968     wakeup(&log);
4969   }
4970   release(&log.lock);
4971 
4972   if(do_commit){
4973     
4974     
4975     commit();
4976     acquire(&log.lock);
4977     log.committing = 0;
4978     wakeup(&log);
4979     release(&log.lock);
4980   }
4981 }
4982 
4983 
4984 static void
4985 write_log(void)
4986 {
4987   int tail;
4988 
4989   for (tail = 0; tail < log.lh.n; tail++) {
4990     struct buf *to = bread(log.dev, log.start+tail+1); 
4991     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4992     memmove(to->data, from->data, BSIZE);
4993     bwrite(to);  
4994     brelse(from);
4995     brelse(to);
4996   }
4997 }
4998 
4999 
5000 static void
5001 commit()
5002 {
5003   if (log.lh.n > 0) {
5004     write_log();     
5005     write_head();    
5006     install_trans(); 
5007     log.lh.n = 0;
5008     write_head();    
5009   }
5010 }
5011 
5012 
5013 
5014 
5015 
5016 
5017 
5018 
5019 
5020 
5021 void
5022 log_write(struct buf *b)
5023 {
5024   int i;
5025 
5026   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5027     panic("too big a transaction");
5028   if (log.outstanding < 1)
5029     panic("log_write outside of trans");
5030 
5031   acquire(&log.lock);
5032   for (i = 0; i < log.lh.n; i++) {
5033     if (log.lh.block[i] == b->blockno)   
5034       break;
5035   }
5036   log.lh.block[i] = b->blockno;
5037   if (i == log.lh.n)
5038     log.lh.n++;
5039   b->flags |= B_DIRTY; 
5040   release(&log.lock);
5041 }
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 
5052 
5053 
5054 
5055 
5056 
5057 
5058 
5059 
5060 
5061 #include "types.h"
5062 #include "defs.h"
5063 #include "param.h"
5064 #include "stat.h"
5065 #include "mmu.h"
5066 #include "proc.h"
5067 #include "spinlock.h"
5068 #include "sleeplock.h"
5069 #include "fs.h"
5070 #include "buf.h"
5071 #include "file.h"
5072 
5073 #define min(a, b) ((a) < (b) ? (a) : (b))
5074 static void itrunc(struct inode*);
5075 
5076 
5077 struct superblock sb;
5078 
5079 
5080 void
5081 readsb(int dev, struct superblock *sb)
5082 {
5083   struct buf *bp;
5084 
5085   bp = bread(dev, 1);
5086   memmove(sb, bp->data, sizeof(*sb));
5087   brelse(bp);
5088 }
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 static void
5102 bzero(int dev, int bno)
5103 {
5104   struct buf *bp;
5105 
5106   bp = bread(dev, bno);
5107   memset(bp->data, 0, BSIZE);
5108   log_write(bp);
5109   brelse(bp);
5110 }
5111 
5112 
5113 
5114 
5115 static uint
5116 balloc(uint dev)
5117 {
5118   int b, bi, m;
5119   struct buf *bp;
5120 
5121   bp = 0;
5122   for(b = 0; b < sb.size; b += BPB){
5123     bp = bread(dev, BBLOCK(b, sb));
5124     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5125       m = 1 << (bi % 8);
5126       if((bp->data[bi/8] & m) == 0){  
5127         bp->data[bi/8] |= m;  
5128         log_write(bp);
5129         brelse(bp);
5130         bzero(dev, b + bi);
5131         return b + bi;
5132       }
5133     }
5134     brelse(bp);
5135   }
5136   panic("balloc: out of blocks");
5137 }
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 static void
5152 bfree(int dev, uint b)
5153 {
5154   struct buf *bp;
5155   int bi, m;
5156 
5157   bp = bread(dev, BBLOCK(b, sb));
5158   bi = b % BPB;
5159   m = 1 << (bi % 8);
5160   if((bp->data[bi/8] & m) == 0)
5161     panic("freeing free block");
5162   bp->data[bi/8] &= ~m;
5163   log_write(bp);
5164   brelse(bp);
5165 }
5166 
5167 
5168 
5169 
5170 
5171 
5172 
5173 
5174 
5175 
5176 
5177 
5178 
5179 
5180 
5181 
5182 
5183 
5184 
5185 
5186 
5187 
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 
5203 
5204 
5205 
5206 
5207 
5208 
5209 
5210 
5211 
5212 
5213 
5214 
5215 
5216 
5217 
5218 
5219 
5220 
5221 
5222 
5223 
5224 
5225 
5226 
5227 
5228 
5229 
5230 
5231 
5232 
5233 
5234 
5235 
5236 struct {
5237   struct spinlock lock;
5238   struct inode inode[NINODE];
5239 } icache;
5240 
5241 void
5242 iinit(int dev)
5243 {
5244   int i = 0;
5245 
5246   initlock(&icache.lock, "icache");
5247   for(i = 0; i < NINODE; i++) {
5248     initsleeplock(&icache.inode[i].lock, "inode");
5249   }
5250   readsb(dev, &sb);
5251   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5252  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5253           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5254           sb.bmapstart);
5255 }
5256 
5257 static struct inode* iget(uint dev, uint inum);
5258 
5259 
5260 
5261 
5262 
5263 
5264 
5265 
5266 
5267 
5268 
5269 
5270 
5271 
5272 
5273 
5274 
5275 
5276 
5277 
5278 
5279 
5280 
5281 
5282 
5283 
5284 
5285 
5286 
5287 
5288 
5289 
5290 
5291 
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 
5302 
5303 struct inode*
5304 ialloc(uint dev, short type)
5305 {
5306   int inum;
5307   struct buf *bp;
5308   struct dinode *dip;
5309 
5310   for(inum = 1; inum < sb.ninodes; inum++){
5311     bp = bread(dev, IBLOCK(inum, sb));
5312     dip = (struct dinode*)bp->data + inum%IPB;
5313     if(dip->type == 0){  
5314       memset(dip, 0, sizeof(*dip));
5315       dip->type = type;
5316       log_write(bp);   
5317       brelse(bp);
5318       return iget(dev, inum);
5319     }
5320     brelse(bp);
5321   }
5322   panic("ialloc: no inodes");
5323 }
5324 
5325 
5326 
5327 
5328 
5329 void
5330 iupdate(struct inode *ip)
5331 {
5332   struct buf *bp;
5333   struct dinode *dip;
5334 
5335   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5336   dip = (struct dinode*)bp->data + ip->inum%IPB;
5337   dip->type = ip->type;
5338   dip->major = ip->major;
5339   dip->minor = ip->minor;
5340   dip->nlink = ip->nlink;
5341   dip->size = ip->size;
5342   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5343   log_write(bp);
5344   brelse(bp);
5345 }
5346 
5347 
5348 
5349 
5350 
5351 
5352 
5353 static struct inode*
5354 iget(uint dev, uint inum)
5355 {
5356   struct inode *ip, *empty;
5357 
5358   acquire(&icache.lock);
5359 
5360   
5361   empty = 0;
5362   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5363     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5364       ip->ref++;
5365       release(&icache.lock);
5366       return ip;
5367     }
5368     if(empty == 0 && ip->ref == 0)    
5369       empty = ip;
5370   }
5371 
5372   
5373   if(empty == 0)
5374     panic("iget: no inodes");
5375 
5376   ip = empty;
5377   ip->dev = dev;
5378   ip->inum = inum;
5379   ip->ref = 1;
5380   ip->valid = 0;
5381   release(&icache.lock);
5382 
5383   return ip;
5384 }
5385 
5386 
5387 
5388 struct inode*
5389 idup(struct inode *ip)
5390 {
5391   acquire(&icache.lock);
5392   ip->ref++;
5393   release(&icache.lock);
5394   return ip;
5395 }
5396 
5397 
5398 
5399 
5400 
5401 
5402 void
5403 ilock(struct inode *ip)
5404 {
5405   struct buf *bp;
5406   struct dinode *dip;
5407 
5408   if(ip == 0 || ip->ref < 1)
5409     panic("ilock");
5410 
5411   acquiresleep(&ip->lock);
5412 
5413   if(ip->valid == 0){
5414     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5415     dip = (struct dinode*)bp->data + ip->inum%IPB;
5416     ip->type = dip->type;
5417     ip->major = dip->major;
5418     ip->minor = dip->minor;
5419     ip->nlink = dip->nlink;
5420     ip->size = dip->size;
5421     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5422     brelse(bp);
5423     ip->valid = 1;
5424     if(ip->type == 0)
5425       panic("ilock: no type");
5426   }
5427 }
5428 
5429 
5430 void
5431 iunlock(struct inode *ip)
5432 {
5433   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5434     panic("iunlock");
5435 
5436   releasesleep(&ip->lock);
5437 }
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 
5454 
5455 
5456 
5457 void
5458 iput(struct inode *ip)
5459 {
5460   acquiresleep(&ip->lock);
5461   if(ip->valid && ip->nlink == 0){
5462     acquire(&icache.lock);
5463     int r = ip->ref;
5464     release(&icache.lock);
5465     if(r == 1){
5466       
5467       itrunc(ip);
5468       ip->type = 0;
5469       iupdate(ip);
5470       ip->valid = 0;
5471     }
5472   }
5473   releasesleep(&ip->lock);
5474 
5475   acquire(&icache.lock);
5476   ip->ref--;
5477   release(&icache.lock);
5478 }
5479 
5480 
5481 void
5482 iunlockput(struct inode *ip)
5483 {
5484   iunlock(ip);
5485   iput(ip);
5486 }
5487 
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 
5506 
5507 
5508 
5509 static uint
5510 bmap(struct inode *ip, uint bn)
5511 {
5512   uint addr, *a;
5513   struct buf *bp;
5514 
5515   if(bn < NDIRECT){
5516     if((addr = ip->addrs[bn]) == 0)
5517       ip->addrs[bn] = addr = balloc(ip->dev);
5518     return addr;
5519   }
5520   bn -= NDIRECT;
5521 
5522   if(bn < NINDIRECT){
5523     
5524     if((addr = ip->addrs[NDIRECT]) == 0)
5525       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5526     bp = bread(ip->dev, addr);
5527     a = (uint*)bp->data;
5528     if((addr = a[bn]) == 0){
5529       a[bn] = addr = balloc(ip->dev);
5530       log_write(bp);
5531     }
5532     brelse(bp);
5533     return addr;
5534   }
5535 
5536   panic("bmap: out of range");
5537 }
5538 
5539 
5540 
5541 
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 
5551 
5552 
5553 
5554 
5555 static void
5556 itrunc(struct inode *ip)
5557 {
5558   int i, j;
5559   struct buf *bp;
5560   uint *a;
5561 
5562   for(i = 0; i < NDIRECT; i++){
5563     if(ip->addrs[i]){
5564       bfree(ip->dev, ip->addrs[i]);
5565       ip->addrs[i] = 0;
5566     }
5567   }
5568 
5569   if(ip->addrs[NDIRECT]){
5570     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5571     a = (uint*)bp->data;
5572     for(j = 0; j < NINDIRECT; j++){
5573       if(a[j])
5574         bfree(ip->dev, a[j]);
5575     }
5576     brelse(bp);
5577     bfree(ip->dev, ip->addrs[NDIRECT]);
5578     ip->addrs[NDIRECT] = 0;
5579   }
5580 
5581   ip->size = 0;
5582   iupdate(ip);
5583 }
5584 
5585 
5586 
5587 void
5588 stati(struct inode *ip, struct stat *st)
5589 {
5590   st->dev = ip->dev;
5591   st->ino = ip->inum;
5592   st->type = ip->type;
5593   st->nlink = ip->nlink;
5594   st->size = ip->size;
5595 }
5596 
5597 
5598 
5599 
5600 
5601 
5602 int
5603 readi(struct inode *ip, char *dst, uint off, uint n)
5604 {
5605   uint tot, m;
5606   struct buf *bp;
5607 
5608   if(ip->type == T_DEV){
5609     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5610       return -1;
5611     return devsw[ip->major].read(ip, dst, n);
5612   }
5613 
5614   if(off > ip->size || off + n < off)
5615     return -1;
5616   if(off + n > ip->size)
5617     n = ip->size - off;
5618 
5619   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5620     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5621     m = min(n - tot, BSIZE - off%BSIZE);
5622     memmove(dst, bp->data + off%BSIZE, m);
5623     brelse(bp);
5624   }
5625   return n;
5626 }
5627 
5628 
5629 
5630 
5631 
5632 
5633 
5634 
5635 
5636 
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 
5651 
5652 int
5653 writei(struct inode *ip, char *src, uint off, uint n)
5654 {
5655   uint tot, m;
5656   struct buf *bp;
5657 
5658   if(ip->type == T_DEV){
5659     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5660       return -1;
5661     return devsw[ip->major].write(ip, src, n);
5662   }
5663 
5664   if(off > ip->size || off + n < off)
5665     return -1;
5666   if(off + n > MAXFILE*BSIZE)
5667     return -1;
5668 
5669   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5670     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5671     m = min(n - tot, BSIZE - off%BSIZE);
5672     memmove(bp->data + off%BSIZE, src, m);
5673     log_write(bp);
5674     brelse(bp);
5675   }
5676 
5677   if(n > 0 && off > ip->size){
5678     ip->size = off;
5679     iupdate(ip);
5680   }
5681   return n;
5682 }
5683 
5684 
5685 
5686 
5687 
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 
5702 int
5703 namecmp(const char *s, const char *t)
5704 {
5705   return strncmp(s, t, DIRSIZ);
5706 }
5707 
5708 
5709 
5710 struct inode*
5711 dirlookup(struct inode *dp, char *name, uint *poff)
5712 {
5713   uint off, inum;
5714   struct dirent de;
5715 
5716   if(dp->type != T_DIR)
5717     panic("dirlookup not DIR");
5718 
5719   for(off = 0; off < dp->size; off += sizeof(de)){
5720     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5721       panic("dirlookup read");
5722     if(de.inum == 0)
5723       continue;
5724     if(namecmp(name, de.name) == 0){
5725       
5726       if(poff)
5727         *poff = off;
5728       inum = de.inum;
5729       return iget(dp->dev, inum);
5730     }
5731   }
5732 
5733   return 0;
5734 }
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 int
5752 dirlink(struct inode *dp, char *name, uint inum)
5753 {
5754   int off;
5755   struct dirent de;
5756   struct inode *ip;
5757 
5758   
5759   if((ip = dirlookup(dp, name, 0)) != 0){
5760     iput(ip);
5761     return -1;
5762   }
5763 
5764   
5765   for(off = 0; off < dp->size; off += sizeof(de)){
5766     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5767       panic("dirlink read");
5768     if(de.inum == 0)
5769       break;
5770   }
5771 
5772   strncpy(de.name, name, DIRSIZ);
5773   de.inum = inum;
5774   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5775     panic("dirlink");
5776 
5777   return 0;
5778 }
5779 
5780 
5781 
5782 
5783 
5784 
5785 
5786 
5787 
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 
5802 
5803 
5804 
5805 
5806 
5807 
5808 
5809 
5810 
5811 
5812 
5813 
5814 static char*
5815 skipelem(char *path, char *name)
5816 {
5817   char *s;
5818   int len;
5819 
5820   while(*path == '/')
5821     path++;
5822   if(*path == 0)
5823     return 0;
5824   s = path;
5825   while(*path != '/' && *path != 0)
5826     path++;
5827   len = path - s;
5828   if(len >= DIRSIZ)
5829     memmove(name, s, DIRSIZ);
5830   else {
5831     memmove(name, s, len);
5832     name[len] = 0;
5833   }
5834   while(*path == '/')
5835     path++;
5836   return path;
5837 }
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 
5853 
5854 static struct inode*
5855 namex(char *path, int nameiparent, char *name)
5856 {
5857   struct inode *ip, *next;
5858 
5859   if(*path == '/')
5860     ip = iget(ROOTDEV, ROOTINO);
5861   else
5862     ip = idup(myproc()->cwd);
5863 
5864   while((path = skipelem(path, name)) != 0){
5865     ilock(ip);
5866     if(ip->type != T_DIR){
5867       iunlockput(ip);
5868       return 0;
5869     }
5870     if(nameiparent && *path == '\0'){
5871       
5872       iunlock(ip);
5873       return ip;
5874     }
5875     if((next = dirlookup(ip, name, 0)) == 0){
5876       iunlockput(ip);
5877       return 0;
5878     }
5879     iunlockput(ip);
5880     ip = next;
5881   }
5882   if(nameiparent){
5883     iput(ip);
5884     return 0;
5885   }
5886   return ip;
5887 }
5888 
5889 struct inode*
5890 namei(char *path)
5891 {
5892   char name[DIRSIZ];
5893   return namex(path, 0, name);
5894 }
5895 
5896 
5897 
5898 
5899 
5900 struct inode*
5901 nameiparent(char *path, char *name)
5902 {
5903   return namex(path, 1, name);
5904 }
5905 
5906 
5907 
5908 
5909 
5910 
5911 
5912 
5913 
5914 
5915 
5916 
5917 
5918 
5919 
5920 
5921 
5922 
5923 
5924 
5925 
5926 
5927 
5928 
5929 
5930 
5931 
5932 
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 
5953 
5954 #include "types.h"
5955 #include "defs.h"
5956 #include "param.h"
5957 #include "fs.h"
5958 #include "spinlock.h"
5959 #include "sleeplock.h"
5960 #include "file.h"
5961 
5962 struct devsw devsw[NDEV];
5963 struct {
5964   struct spinlock lock;
5965   struct file file[NFILE];
5966 } ftable;
5967 
5968 void
5969 fileinit(void)
5970 {
5971   initlock(&ftable.lock, "ftable");
5972 }
5973 
5974 
5975 struct file*
5976 filealloc(void)
5977 {
5978   struct file *f;
5979 
5980   acquire(&ftable.lock);
5981   for(f = ftable.file; f < ftable.file + NFILE; f++){
5982     if(f->ref == 0){
5983       f->ref = 1;
5984       release(&ftable.lock);
5985       return f;
5986     }
5987   }
5988   release(&ftable.lock);
5989   return 0;
5990 }
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 struct file*
6002 filedup(struct file *f)
6003 {
6004   acquire(&ftable.lock);
6005   if(f->ref < 1)
6006     panic("filedup");
6007   f->ref++;
6008   release(&ftable.lock);
6009   return f;
6010 }
6011 
6012 
6013 void
6014 fileclose(struct file *f)
6015 {
6016   struct file ff;
6017 
6018   acquire(&ftable.lock);
6019   if(f->ref < 1)
6020     panic("fileclose");
6021   if(--f->ref > 0){
6022     release(&ftable.lock);
6023     return;
6024   }
6025   ff = *f;
6026   f->ref = 0;
6027   f->type = FD_NONE;
6028   release(&ftable.lock);
6029 
6030   if(ff.type == FD_PIPE)
6031     pipeclose(ff.pipe, ff.writable);
6032   else if(ff.type == FD_INODE){
6033     begin_op();
6034     iput(ff.ip);
6035     end_op();
6036   }
6037 }
6038 
6039 
6040 
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 int
6052 filestat(struct file *f, struct stat *st)
6053 {
6054   if(f->type == FD_INODE){
6055     ilock(f->ip);
6056     stati(f->ip, st);
6057     iunlock(f->ip);
6058     return 0;
6059   }
6060   return -1;
6061 }
6062 
6063 
6064 int
6065 fileread(struct file *f, char *addr, int n)
6066 {
6067   int r;
6068 
6069   if(f->readable == 0)
6070     return -1;
6071   if(f->type == FD_PIPE)
6072     return piperead(f->pipe, addr, n);
6073   if(f->type == FD_INODE){
6074     ilock(f->ip);
6075     if((r = readi(f->ip, addr, f->off, n)) > 0)
6076       f->off += r;
6077     iunlock(f->ip);
6078     return r;
6079   }
6080   panic("fileread");
6081 }
6082 
6083 
6084 
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 int
6102 filewrite(struct file *f, char *addr, int n)
6103 {
6104   int r;
6105 
6106   if(f->writable == 0)
6107     return -1;
6108   if(f->type == FD_PIPE)
6109     return pipewrite(f->pipe, addr, n);
6110   if(f->type == FD_INODE){
6111     
6112     
6113     
6114     
6115     
6116     
6117     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6118     int i = 0;
6119     while(i < n){
6120       int n1 = n - i;
6121       if(n1 > max)
6122         n1 = max;
6123 
6124       begin_op();
6125       ilock(f->ip);
6126       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6127         f->off += r;
6128       iunlock(f->ip);
6129       end_op();
6130 
6131       if(r < 0)
6132         break;
6133       if(r != n1)
6134         panic("short filewrite");
6135       i += r;
6136     }
6137     return i == n ? n : -1;
6138   }
6139   panic("filewrite");
6140 }
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 
6152 
6153 
6154 
6155 
6156 #include "types.h"
6157 #include "defs.h"
6158 #include "param.h"
6159 #include "stat.h"
6160 #include "mmu.h"
6161 #include "proc.h"
6162 #include "fs.h"
6163 #include "spinlock.h"
6164 #include "sleeplock.h"
6165 #include "file.h"
6166 #include "fcntl.h"
6167 
6168 
6169 
6170 static int
6171 argfd(int n, int *pfd, struct file **pf)
6172 {
6173   int fd;
6174   struct file *f;
6175 
6176   if(argint(n, &fd) < 0)
6177     return -1;
6178   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6179     return -1;
6180   if(pfd)
6181     *pfd = fd;
6182   if(pf)
6183     *pf = f;
6184   return 0;
6185 }
6186 
6187 
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 
6202 static int
6203 fdalloc(struct file *f)
6204 {
6205   int fd;
6206   struct proc *curproc = myproc();
6207 
6208   for(fd = 0; fd < NOFILE; fd++){
6209     if(curproc->ofile[fd] == 0){
6210       curproc->ofile[fd] = f;
6211       return fd;
6212     }
6213   }
6214   return -1;
6215 }
6216 
6217 int
6218 sys_dup(void)
6219 {
6220   struct file *f;
6221   int fd;
6222 
6223   if(argfd(0, 0, &f) < 0)
6224     return -1;
6225   if((fd=fdalloc(f)) < 0)
6226     return -1;
6227   filedup(f);
6228   return fd;
6229 }
6230 
6231 int
6232 sys_read(void)
6233 {
6234   struct file *f;
6235   int n;
6236   char *p;
6237 
6238   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6239     return -1;
6240   return fileread(f, p, n);
6241 }
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 int
6251 sys_write(void)
6252 {
6253   struct file *f;
6254   int n;
6255   char *p;
6256 
6257   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6258     return -1;
6259   return filewrite(f, p, n);
6260 }
6261 
6262 int
6263 sys_close(void)
6264 {
6265   int fd;
6266   struct file *f;
6267 
6268   if(argfd(0, &fd, &f) < 0)
6269     return -1;
6270   myproc()->ofile[fd] = 0;
6271   fileclose(f);
6272   return 0;
6273 }
6274 
6275 int
6276 sys_fstat(void)
6277 {
6278   struct file *f;
6279   struct stat *st;
6280 
6281   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6282     return -1;
6283   return filestat(f, st);
6284 }
6285 
6286 
6287 
6288 
6289 
6290 
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 
6301 int
6302 sys_link(void)
6303 {
6304   char name[DIRSIZ], *new, *old;
6305   struct inode *dp, *ip;
6306 
6307   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6308     return -1;
6309 
6310   begin_op();
6311   if((ip = namei(old)) == 0){
6312     end_op();
6313     return -1;
6314   }
6315 
6316   ilock(ip);
6317   if(ip->type == T_DIR){
6318     iunlockput(ip);
6319     end_op();
6320     return -1;
6321   }
6322 
6323   ip->nlink++;
6324   iupdate(ip);
6325   iunlock(ip);
6326 
6327   if((dp = nameiparent(new, name)) == 0)
6328     goto bad;
6329   ilock(dp);
6330   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6331     iunlockput(dp);
6332     goto bad;
6333   }
6334   iunlockput(dp);
6335   iput(ip);
6336 
6337   end_op();
6338 
6339   return 0;
6340 
6341 bad:
6342   ilock(ip);
6343   ip->nlink--;
6344   iupdate(ip);
6345   iunlockput(ip);
6346   end_op();
6347   return -1;
6348 }
6349 
6350 
6351 static int
6352 isdirempty(struct inode *dp)
6353 {
6354   int off;
6355   struct dirent de;
6356 
6357   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6358     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6359       panic("isdirempty: readi");
6360     if(de.inum != 0)
6361       return 0;
6362   }
6363   return 1;
6364 }
6365 
6366 
6367 
6368 
6369 
6370 
6371 
6372 
6373 
6374 
6375 
6376 
6377 
6378 
6379 
6380 
6381 
6382 
6383 
6384 
6385 
6386 
6387 
6388 
6389 
6390 
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 int
6401 sys_unlink(void)
6402 {
6403   struct inode *ip, *dp;
6404   struct dirent de;
6405   char name[DIRSIZ], *path;
6406   uint off;
6407 
6408   if(argstr(0, &path) < 0)
6409     return -1;
6410 
6411   begin_op();
6412   if((dp = nameiparent(path, name)) == 0){
6413     end_op();
6414     return -1;
6415   }
6416 
6417   ilock(dp);
6418 
6419   
6420   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6421     goto bad;
6422 
6423   if((ip = dirlookup(dp, name, &off)) == 0)
6424     goto bad;
6425   ilock(ip);
6426 
6427   if(ip->nlink < 1)
6428     panic("unlink: nlink < 1");
6429   if(ip->type == T_DIR && !isdirempty(ip)){
6430     iunlockput(ip);
6431     goto bad;
6432   }
6433 
6434   memset(&de, 0, sizeof(de));
6435   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6436     panic("unlink: writei");
6437   if(ip->type == T_DIR){
6438     dp->nlink--;
6439     iupdate(dp);
6440   }
6441   iunlockput(dp);
6442 
6443   ip->nlink--;
6444   iupdate(ip);
6445   iunlockput(ip);
6446 
6447   end_op();
6448 
6449   return 0;
6450 bad:
6451   iunlockput(dp);
6452   end_op();
6453   return -1;
6454 }
6455 
6456 static struct inode*
6457 create(char *path, short type, short major, short minor)
6458 {
6459   struct inode *ip, *dp;
6460   char name[DIRSIZ];
6461 
6462   if((dp = nameiparent(path, name)) == 0)
6463     return 0;
6464   ilock(dp);
6465 
6466   if((ip = dirlookup(dp, name, 0)) != 0){
6467     iunlockput(dp);
6468     ilock(ip);
6469     if(type == T_FILE && ip->type == T_FILE)
6470       return ip;
6471     iunlockput(ip);
6472     return 0;
6473   }
6474 
6475   if((ip = ialloc(dp->dev, type)) == 0)
6476     panic("create: ialloc");
6477 
6478   ilock(ip);
6479   ip->major = major;
6480   ip->minor = minor;
6481   ip->nlink = 1;
6482   iupdate(ip);
6483 
6484   if(type == T_DIR){  
6485     dp->nlink++;  
6486     iupdate(dp);
6487     
6488     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6489       panic("create dots");
6490   }
6491 
6492   if(dirlink(dp, name, ip->inum) < 0)
6493     panic("create: dirlink");
6494 
6495   iunlockput(dp);
6496 
6497   return ip;
6498 }
6499 
6500 int
6501 sys_open(void)
6502 {
6503   char *path;
6504   int fd, omode;
6505   struct file *f;
6506   struct inode *ip;
6507 
6508   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6509     return -1;
6510 
6511   begin_op();
6512 
6513   if(omode & O_CREATE){
6514     ip = create(path, T_FILE, 0, 0);
6515     if(ip == 0){
6516       end_op();
6517       return -1;
6518     }
6519   } else {
6520     if((ip = namei(path)) == 0){
6521       end_op();
6522       return -1;
6523     }
6524     ilock(ip);
6525     if(ip->type == T_DIR && omode != O_RDONLY){
6526       iunlockput(ip);
6527       end_op();
6528       return -1;
6529     }
6530   }
6531 
6532   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6533     if(f)
6534       fileclose(f);
6535     iunlockput(ip);
6536     end_op();
6537     return -1;
6538   }
6539   iunlock(ip);
6540   end_op();
6541 
6542   f->type = FD_INODE;
6543   f->ip = ip;
6544   f->off = 0;
6545   f->readable = !(omode & O_WRONLY);
6546   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6547   return fd;
6548 }
6549 
6550 int
6551 sys_mkdir(void)
6552 {
6553   char *path;
6554   struct inode *ip;
6555 
6556   begin_op();
6557   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6558     end_op();
6559     return -1;
6560   }
6561   iunlockput(ip);
6562   end_op();
6563   return 0;
6564 }
6565 
6566 int
6567 sys_mknod(void)
6568 {
6569   struct inode *ip;
6570   char *path;
6571   int major, minor;
6572 
6573   begin_op();
6574   if((argstr(0, &path)) < 0 ||
6575      argint(1, &major) < 0 ||
6576      argint(2, &minor) < 0 ||
6577      (ip = create(path, T_DEV, major, minor)) == 0){
6578     end_op();
6579     return -1;
6580   }
6581   iunlockput(ip);
6582   end_op();
6583   return 0;
6584 }
6585 
6586 
6587 
6588 
6589 
6590 
6591 
6592 
6593 
6594 
6595 
6596 
6597 
6598 
6599 
6600 int
6601 sys_chdir(void)
6602 {
6603   char *path;
6604   struct inode *ip;
6605   struct proc *curproc = myproc();
6606 
6607   begin_op();
6608   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6609     end_op();
6610     return -1;
6611   }
6612   ilock(ip);
6613   if(ip->type != T_DIR){
6614     iunlockput(ip);
6615     end_op();
6616     return -1;
6617   }
6618   iunlock(ip);
6619   iput(curproc->cwd);
6620   end_op();
6621   curproc->cwd = ip;
6622   return 0;
6623 }
6624 
6625 int
6626 sys_exec(void)
6627 {
6628   char *path, *argv[MAXARG];
6629   int i;
6630   uint uargv, uarg;
6631 
6632   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6633     return -1;
6634   }
6635   memset(argv, 0, sizeof(argv));
6636   for(i=0;; i++){
6637     if(i >= NELEM(argv))
6638       return -1;
6639     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6640       return -1;
6641     if(uarg == 0){
6642       argv[i] = 0;
6643       break;
6644     }
6645     if(fetchstr(uarg, &argv[i]) < 0)
6646       return -1;
6647   }
6648   return exec(path, argv);
6649 }
6650 int
6651 sys_pipe(void)
6652 {
6653   int *fd;
6654   struct file *rf, *wf;
6655   int fd0, fd1;
6656 
6657   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6658     return -1;
6659   if(pipealloc(&rf, &wf) < 0)
6660     return -1;
6661   fd0 = -1;
6662   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6663     if(fd0 >= 0)
6664       myproc()->ofile[fd0] = 0;
6665     fileclose(rf);
6666     fileclose(wf);
6667     return -1;
6668   }
6669   fd[0] = fd0;
6670   fd[1] = fd1;
6671   return 0;
6672 }
6673 
6674 
6675 
6676 
6677 
6678 
6679 
6680 
6681 
6682 
6683 
6684 
6685 
6686 
6687 
6688 
6689 
6690 
6691 
6692 
6693 
6694 
6695 
6696 
6697 
6698 
6699 
6700 #include "types.h"
6701 #include "param.h"
6702 #include "memlayout.h"
6703 #include "mmu.h"
6704 #include "proc.h"
6705 #include "defs.h"
6706 #include "x86.h"
6707 #include "elf.h"
6708 
6709 int
6710 exec(char *path, char **argv)
6711 {
6712   char *s, *last;
6713   int i, off;
6714   uint argc, sz, sp, ustack[3+MAXARG+1];
6715   struct elfhdr elf;
6716   struct inode *ip;
6717   struct proghdr ph;
6718   pde_t *pgdir, *oldpgdir;
6719   struct proc *curproc = myproc();
6720 
6721   begin_op();
6722 
6723   if((ip = namei(path)) == 0){
6724     end_op();
6725     cprintf("exec: fail\n");
6726     return -1;
6727   }
6728   ilock(ip);
6729   pgdir = 0;
6730 
6731   
6732   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6733     goto bad;
6734   if(elf.magic != ELF_MAGIC)
6735     goto bad;
6736 
6737   if((pgdir = setupkvm()) == 0)
6738     goto bad;
6739 
6740   
6741   sz = 0;
6742   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6743     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6744       goto bad;
6745     if(ph.type != ELF_PROG_LOAD)
6746       continue;
6747     if(ph.memsz < ph.filesz)
6748       goto bad;
6749     if(ph.vaddr + ph.memsz < ph.vaddr)
6750       goto bad;
6751     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6752       goto bad;
6753     if(ph.vaddr % PGSIZE != 0)
6754       goto bad;
6755     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6756       goto bad;
6757   }
6758   iunlockput(ip);
6759   end_op();
6760   ip = 0;
6761 
6762   
6763   
6764   sz = PGROUNDUP(sz);
6765   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6766     goto bad;
6767   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6768   sp = sz;
6769 
6770   
6771   for(argc = 0; argv[argc]; argc++) {
6772     if(argc >= MAXARG)
6773       goto bad;
6774     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6775     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6776       goto bad;
6777     ustack[3+argc] = sp;
6778   }
6779   ustack[3+argc] = 0;
6780 
6781   ustack[0] = 0xffffffff;  
6782   ustack[1] = argc;
6783   ustack[2] = sp - (argc+1)*4;  
6784 
6785   sp -= (3+argc+1) * 4;
6786   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6787     goto bad;
6788 
6789   
6790   for(last=s=path; *s; s++)
6791     if(*s == '/')
6792       last = s+1;
6793   safestrcpy(curproc->name, last, sizeof(curproc->name));
6794 
6795   
6796   oldpgdir = curproc->pgdir;
6797   curproc->pgdir = pgdir;
6798   curproc->sz = sz;
6799   curproc->tf->eip = elf.entry;  
6800   curproc->tf->esp = sp;
6801   switchuvm(curproc);
6802   freevm(oldpgdir);
6803   return 0;
6804 
6805  bad:
6806   if(pgdir)
6807     freevm(pgdir);
6808   if(ip){
6809     iunlockput(ip);
6810     end_op();
6811   }
6812   return -1;
6813 }
6814 
6815 
6816 
6817 
6818 
6819 
6820 
6821 
6822 
6823 
6824 
6825 
6826 
6827 
6828 
6829 
6830 
6831 
6832 
6833 
6834 
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 #include "types.h"
6851 #include "defs.h"
6852 #include "param.h"
6853 #include "mmu.h"
6854 #include "proc.h"
6855 #include "fs.h"
6856 #include "spinlock.h"
6857 #include "sleeplock.h"
6858 #include "file.h"
6859 
6860 #define PIPESIZE 512
6861 
6862 struct pipe {
6863   struct spinlock lock;
6864   char data[PIPESIZE];
6865   uint nread;     
6866   uint nwrite;    
6867   int readopen;   
6868   int writeopen;  
6869 };
6870 
6871 int
6872 pipealloc(struct file **f0, struct file **f1)
6873 {
6874   struct pipe *p;
6875 
6876   p = 0;
6877   *f0 = *f1 = 0;
6878   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6879     goto bad;
6880   if((p = (struct pipe*)kalloc()) == 0)
6881     goto bad;
6882   p->readopen = 1;
6883   p->writeopen = 1;
6884   p->nwrite = 0;
6885   p->nread = 0;
6886   initlock(&p->lock, "pipe");
6887   (*f0)->type = FD_PIPE;
6888   (*f0)->readable = 1;
6889   (*f0)->writable = 0;
6890   (*f0)->pipe = p;
6891   (*f1)->type = FD_PIPE;
6892   (*f1)->readable = 0;
6893   (*f1)->writable = 1;
6894   (*f1)->pipe = p;
6895   return 0;
6896 
6897 
6898 
6899 
6900  bad:
6901   if(p)
6902     kfree((char*)p);
6903   if(*f0)
6904     fileclose(*f0);
6905   if(*f1)
6906     fileclose(*f1);
6907   return -1;
6908 }
6909 
6910 void
6911 pipeclose(struct pipe *p, int writable)
6912 {
6913   acquire(&p->lock);
6914   if(writable){
6915     p->writeopen = 0;
6916     wakeup(&p->nread);
6917   } else {
6918     p->readopen = 0;
6919     wakeup(&p->nwrite);
6920   }
6921   if(p->readopen == 0 && p->writeopen == 0){
6922     release(&p->lock);
6923     kfree((char*)p);
6924   } else
6925     release(&p->lock);
6926 }
6927 
6928 
6929 int
6930 pipewrite(struct pipe *p, char *addr, int n)
6931 {
6932   int i;
6933 
6934   acquire(&p->lock);
6935   for(i = 0; i < n; i++){
6936     while(p->nwrite == p->nread + PIPESIZE){  
6937       if(p->readopen == 0 || myproc()->killed){
6938         release(&p->lock);
6939         return -1;
6940       }
6941       wakeup(&p->nread);
6942       sleep(&p->nwrite, &p->lock);  
6943     }
6944     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6945   }
6946   wakeup(&p->nread);  
6947   release(&p->lock);
6948   return n;
6949 }
6950 int
6951 piperead(struct pipe *p, char *addr, int n)
6952 {
6953   int i;
6954 
6955   acquire(&p->lock);
6956   while(p->nread == p->nwrite && p->writeopen){  
6957     if(myproc()->killed){
6958       release(&p->lock);
6959       return -1;
6960     }
6961     sleep(&p->nread, &p->lock); 
6962   }
6963   for(i = 0; i < n; i++){  
6964     if(p->nread == p->nwrite)
6965       break;
6966     addr[i] = p->data[p->nread++ % PIPESIZE];
6967   }
6968   wakeup(&p->nwrite);  
6969   release(&p->lock);
6970   return i;
6971 }
6972 
6973 
6974 
6975 
6976 
6977 
6978 
6979 
6980 
6981 
6982 
6983 
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 #include "types.h"
7001 #include "x86.h"
7002 
7003 void*
7004 memset(void *dst, int c, uint n)
7005 {
7006   if ((int)dst%4 == 0 && n%4 == 0){
7007     c &= 0xFF;
7008     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7009   } else
7010     stosb(dst, c, n);
7011   return dst;
7012 }
7013 
7014 int
7015 memcmp(const void *v1, const void *v2, uint n)
7016 {
7017   const uchar *s1, *s2;
7018 
7019   s1 = v1;
7020   s2 = v2;
7021   while(n-- > 0){
7022     if(*s1 != *s2)
7023       return *s1 - *s2;
7024     s1++, s2++;
7025   }
7026 
7027   return 0;
7028 }
7029 
7030 void*
7031 memmove(void *dst, const void *src, uint n)
7032 {
7033   const char *s;
7034   char *d;
7035 
7036   s = src;
7037   d = dst;
7038   if(s < d && s + n > d){
7039     s += n;
7040     d += n;
7041     while(n-- > 0)
7042       *--d = *--s;
7043   } else
7044     while(n-- > 0)
7045       *d++ = *s++;
7046 
7047   return dst;
7048 }
7049 
7050 
7051 void*
7052 memcpy(void *dst, const void *src, uint n)
7053 {
7054   return memmove(dst, src, n);
7055 }
7056 
7057 int
7058 strncmp(const char *p, const char *q, uint n)
7059 {
7060   while(n > 0 && *p && *p == *q)
7061     n--, p++, q++;
7062   if(n == 0)
7063     return 0;
7064   return (uchar)*p - (uchar)*q;
7065 }
7066 
7067 char*
7068 strncpy(char *s, const char *t, int n)
7069 {
7070   char *os;
7071 
7072   os = s;
7073   while(n-- > 0 && (*s++ = *t++) != 0)
7074     ;
7075   while(n-- > 0)
7076     *s++ = 0;
7077   return os;
7078 }
7079 
7080 
7081 char*
7082 safestrcpy(char *s, const char *t, int n)
7083 {
7084   char *os;
7085 
7086   os = s;
7087   if(n <= 0)
7088     return os;
7089   while(--n > 0 && (*s++ = *t++) != 0)
7090     ;
7091   *s = 0;
7092   return os;
7093 }
7094 
7095 
7096 
7097 
7098 
7099 
7100 int
7101 strlen(const char *s)
7102 {
7103   int n;
7104 
7105   for(n = 0; s[n]; n++)
7106     ;
7107   return n;
7108 }
7109 
7110 
7111 
7112 
7113 
7114 
7115 
7116 
7117 
7118 
7119 
7120 
7121 
7122 
7123 
7124 
7125 
7126 
7127 
7128 
7129 
7130 
7131 
7132 
7133 
7134 
7135 
7136 
7137 
7138 
7139 
7140 
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 
7151 
7152 struct mp {             
7153   uchar signature[4];           
7154   void *physaddr;               
7155   uchar length;                 
7156   uchar specrev;                
7157   uchar checksum;               
7158   uchar type;                   
7159   uchar imcrp;
7160   uchar reserved[3];
7161 };
7162 
7163 struct mpconf {         
7164   uchar signature[4];           
7165   ushort length;                
7166   uchar version;                
7167   uchar checksum;               
7168   uchar product[20];            
7169   uint *oemtable;               
7170   ushort oemlength;             
7171   ushort entry;                 
7172   uint *lapicaddr;              
7173   ushort xlength;               
7174   uchar xchecksum;              
7175   uchar reserved;
7176 };
7177 
7178 struct mpproc {         
7179   uchar type;                   
7180   uchar apicid;                 
7181   uchar version;                
7182   uchar flags;                  
7183     #define MPBOOT 0x02           
7184   uchar signature[4];           
7185   uint feature;                 
7186   uchar reserved[8];
7187 };
7188 
7189 struct mpioapic {       
7190   uchar type;                   
7191   uchar apicno;                 
7192   uchar version;                
7193   uchar flags;                  
7194   uint *addr;                  
7195 };
7196 
7197 
7198 
7199 
7200 
7201 #define MPPROC    0x00  
7202 #define MPBUS     0x01  
7203 #define MPIOAPIC  0x02  
7204 #define MPIOINTR  0x03  
7205 #define MPLINTR   0x04  
7206 
7207 
7208 
7209 
7210 
7211 
7212 
7213 
7214 
7215 
7216 
7217 
7218 
7219 
7220 
7221 
7222 
7223 
7224 
7225 
7226 
7227 
7228 
7229 
7230 
7231 
7232 
7233 
7234 
7235 
7236 
7237 
7238 
7239 
7240 
7241 
7242 
7243 
7244 
7245 
7246 
7247 
7248 
7249 
7250 
7251 
7252 
7253 
7254 
7255 
7256 
7257 
7258 
7259 
7260 
7261 
7262 
7263 
7264 
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 
7301 
7302 
7303 
7304 #include "types.h"
7305 #include "defs.h"
7306 #include "param.h"
7307 #include "memlayout.h"
7308 #include "mp.h"
7309 #include "x86.h"
7310 #include "mmu.h"
7311 #include "proc.h"
7312 
7313 struct cpu cpus[NCPU];
7314 int ncpu;
7315 uchar ioapicid;
7316 
7317 static uchar
7318 sum(uchar *addr, int len)
7319 {
7320   int i, sum;
7321 
7322   sum = 0;
7323   for(i=0; i<len; i++)
7324     sum += addr[i];
7325   return sum;
7326 }
7327 
7328 
7329 static struct mp*
7330 mpsearch1(uint a, int len)
7331 {
7332   uchar *e, *p, *addr;
7333 
7334   addr = P2V(a);
7335   e = addr+len;
7336   for(p = addr; p < e; p += sizeof(struct mp))
7337     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7338       return (struct mp*)p;
7339   return 0;
7340 }
7341 
7342 
7343 
7344 
7345 
7346 
7347 
7348 
7349 
7350 
7351 
7352 
7353 
7354 
7355 static struct mp*
7356 mpsearch(void)
7357 {
7358   uchar *bda;
7359   uint p;
7360   struct mp *mp;
7361 
7362   bda = (uchar *) P2V(0x400);
7363   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7364     if((mp = mpsearch1(p, 1024)))
7365       return mp;
7366   } else {
7367     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7368     if((mp = mpsearch1(p-1024, 1024)))
7369       return mp;
7370   }
7371   return mpsearch1(0xF0000, 0x10000);
7372 }
7373 
7374 
7375 
7376 
7377 
7378 
7379 static struct mpconf*
7380 mpconfig(struct mp **pmp)
7381 {
7382   struct mpconf *conf;
7383   struct mp *mp;
7384 
7385   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7386     return 0;
7387   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7388   if(memcmp(conf, "PCMP", 4) != 0)
7389     return 0;
7390   if(conf->version != 1 && conf->version != 4)
7391     return 0;
7392   if(sum((uchar*)conf, conf->length) != 0)
7393     return 0;
7394   *pmp = mp;
7395   return conf;
7396 }
7397 
7398 
7399 
7400 void
7401 mpinit(void)
7402 {
7403   uchar *p, *e;
7404   int ismp;
7405   struct mp *mp;
7406   struct mpconf *conf;
7407   struct mpproc *proc;
7408   struct mpioapic *ioapic;
7409 
7410   if((conf = mpconfig(&mp)) == 0)
7411     panic("Expect to run on an SMP");
7412   ismp = 1;
7413   lapic = (uint*)conf->lapicaddr;
7414   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7415     switch(*p){
7416     case MPPROC:
7417       proc = (struct mpproc*)p;
7418       if(ncpu < NCPU) {
7419         cpus[ncpu].apicid = proc->apicid;  
7420         ncpu++;
7421       }
7422       p += sizeof(struct mpproc);
7423       continue;
7424     case MPIOAPIC:
7425       ioapic = (struct mpioapic*)p;
7426       ioapicid = ioapic->apicno;
7427       p += sizeof(struct mpioapic);
7428       continue;
7429     case MPBUS:
7430     case MPIOINTR:
7431     case MPLINTR:
7432       p += 8;
7433       continue;
7434     default:
7435       ismp = 0;
7436       break;
7437     }
7438   }
7439   if(!ismp)
7440     panic("Didn't find a suitable machine");
7441 
7442   if(mp->imcrp){
7443     
7444     
7445     outb(0x22, 0x70);   
7446     outb(0x23, inb(0x23) | 1);  
7447   }
7448 }
7449 
7450 
7451 
7452 
7453 #include "param.h"
7454 #include "types.h"
7455 #include "defs.h"
7456 #include "date.h"
7457 #include "memlayout.h"
7458 #include "traps.h"
7459 #include "mmu.h"
7460 #include "x86.h"
7461 
7462 
7463 #define ID      (0x0020/4)   
7464 #define VER     (0x0030/4)   
7465 #define TPR     (0x0080/4)   
7466 #define EOI     (0x00B0/4)   
7467 #define SVR     (0x00F0/4)   
7468   #define ENABLE     0x00000100   
7469 #define ESR     (0x0280/4)   
7470 #define ICRLO   (0x0300/4)   
7471   #define INIT       0x00000500   
7472   #define STARTUP    0x00000600   
7473   #define DELIVS     0x00001000   
7474   #define ASSERT     0x00004000   
7475   #define DEASSERT   0x00000000
7476   #define LEVEL      0x00008000   
7477   #define BCAST      0x00080000   
7478   #define BUSY       0x00001000
7479   #define FIXED      0x00000000
7480 #define ICRHI   (0x0310/4)   
7481 #define TIMER   (0x0320/4)   
7482   #define X1         0x0000000B   
7483   #define PERIODIC   0x00020000   
7484 #define PCINT   (0x0340/4)   
7485 #define LINT0   (0x0350/4)   
7486 #define LINT1   (0x0360/4)   
7487 #define ERROR   (0x0370/4)   
7488   #define MASKED     0x00010000   
7489 #define TICR    (0x0380/4)   
7490 #define TCCR    (0x0390/4)   
7491 #define TDCR    (0x03E0/4)   
7492 
7493 volatile uint *lapic;  
7494 
7495 
7496 
7497 
7498 
7499 
7500 static void
7501 lapicw(int index, int value)
7502 {
7503   lapic[index] = value;
7504   lapic[ID];  
7505 }
7506 
7507 void
7508 lapicinit(void)
7509 {
7510   if(!lapic)
7511     return;
7512 
7513   
7514   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7515 
7516   
7517   
7518   
7519   
7520   lapicw(TDCR, X1);
7521   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7522   lapicw(TICR, 10000000);
7523 
7524   
7525   lapicw(LINT0, MASKED);
7526   lapicw(LINT1, MASKED);
7527 
7528   
7529   
7530   if(((lapic[VER]>>16) & 0xFF) >= 4)
7531     lapicw(PCINT, MASKED);
7532 
7533   
7534   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7535 
7536   
7537   lapicw(ESR, 0);
7538   lapicw(ESR, 0);
7539 
7540   
7541   lapicw(EOI, 0);
7542 
7543   
7544   lapicw(ICRHI, 0);
7545   lapicw(ICRLO, BCAST | INIT | LEVEL);
7546   while(lapic[ICRLO] & DELIVS)
7547     ;
7548 
7549 
7550   
7551   lapicw(TPR, 0);
7552 }
7553 
7554 int
7555 lapicid(void)
7556 {
7557   if (!lapic)
7558     return 0;
7559   return lapic[ID] >> 24;
7560 }
7561 
7562 
7563 void
7564 lapiceoi(void)
7565 {
7566   if(lapic)
7567     lapicw(EOI, 0);
7568 }
7569 
7570 
7571 
7572 void
7573 microdelay(int us)
7574 {
7575 }
7576 
7577 #define CMOS_PORT    0x70
7578 #define CMOS_RETURN  0x71
7579 
7580 
7581 
7582 void
7583 lapicstartap(uchar apicid, uint addr)
7584 {
7585   int i;
7586   ushort *wrv;
7587 
7588   
7589   
7590   
7591   outb(CMOS_PORT, 0xF);  
7592   outb(CMOS_PORT+1, 0x0A);
7593   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7594   wrv[0] = 0;
7595   wrv[1] = addr >> 4;
7596 
7597 
7598 
7599 
7600   
7601   
7602   lapicw(ICRHI, apicid<<24);
7603   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7604   microdelay(200);
7605   lapicw(ICRLO, INIT | LEVEL);
7606   microdelay(100);    
7607 
7608   
7609   
7610   
7611   
7612   
7613   for(i = 0; i < 2; i++){
7614     lapicw(ICRHI, apicid<<24);
7615     lapicw(ICRLO, STARTUP | (addr>>12));
7616     microdelay(200);
7617   }
7618 }
7619 
7620 #define CMOS_STATA   0x0a
7621 #define CMOS_STATB   0x0b
7622 #define CMOS_UIP    (1 << 7)        
7623 
7624 #define SECS    0x00
7625 #define MINS    0x02
7626 #define HOURS   0x04
7627 #define DAY     0x07
7628 #define MONTH   0x08
7629 #define YEAR    0x09
7630 
7631 static uint
7632 cmos_read(uint reg)
7633 {
7634   outb(CMOS_PORT,  reg);
7635   microdelay(200);
7636 
7637   return inb(CMOS_RETURN);
7638 }
7639 
7640 static void
7641 fill_rtcdate(struct rtcdate *r)
7642 {
7643   r->second = cmos_read(SECS);
7644   r->minute = cmos_read(MINS);
7645   r->hour   = cmos_read(HOURS);
7646   r->day    = cmos_read(DAY);
7647   r->month  = cmos_read(MONTH);
7648   r->year   = cmos_read(YEAR);
7649 }
7650 
7651 void
7652 cmostime(struct rtcdate *r)
7653 {
7654   struct rtcdate t1, t2;
7655   int sb, bcd;
7656 
7657   sb = cmos_read(CMOS_STATB);
7658 
7659   bcd = (sb & (1 << 2)) == 0;
7660 
7661   
7662   for(;;) {
7663     fill_rtcdate(&t1);
7664     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7665         continue;
7666     fill_rtcdate(&t2);
7667     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7668       break;
7669   }
7670 
7671   
7672   if(bcd) {
7673 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7674     CONV(second);
7675     CONV(minute);
7676     CONV(hour  );
7677     CONV(day   );
7678     CONV(month );
7679     CONV(year  );
7680 #undef     CONV
7681   }
7682 
7683   *r = t1;
7684   r->year += 2000;
7685 }
7686 
7687 
7688 
7689 
7690 
7691 
7692 
7693 
7694 
7695 
7696 
7697 
7698 
7699 
7700 
7701 
7702 
7703 
7704 #include "types.h"
7705 #include "defs.h"
7706 #include "traps.h"
7707 
7708 #define IOAPIC  0xFEC00000   
7709 
7710 #define REG_ID     0x00  
7711 #define REG_VER    0x01  
7712 #define REG_TABLE  0x10  
7713 
7714 
7715 
7716 
7717 
7718 
7719 #define INT_DISABLED   0x00010000  
7720 #define INT_LEVEL      0x00008000  
7721 #define INT_ACTIVELOW  0x00002000  
7722 #define INT_LOGICAL    0x00000800  
7723 
7724 volatile struct ioapic *ioapic;
7725 
7726 
7727 struct ioapic {
7728   uint reg;
7729   uint pad[3];
7730   uint data;
7731 };
7732 
7733 static uint
7734 ioapicread(int reg)
7735 {
7736   ioapic->reg = reg;
7737   return ioapic->data;
7738 }
7739 
7740 static void
7741 ioapicwrite(int reg, uint data)
7742 {
7743   ioapic->reg = reg;
7744   ioapic->data = data;
7745 }
7746 
7747 
7748 
7749 
7750 void
7751 ioapicinit(void)
7752 {
7753   int i, id, maxintr;
7754 
7755   ioapic = (volatile struct ioapic*)IOAPIC;
7756   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7757   id = ioapicread(REG_ID) >> 24;
7758   if(id != ioapicid)
7759     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7760 
7761   
7762   
7763   for(i = 0; i <= maxintr; i++){
7764     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7765     ioapicwrite(REG_TABLE+2*i+1, 0);
7766   }
7767 }
7768 
7769 void
7770 ioapicenable(int irq, int cpunum)
7771 {
7772   
7773   
7774   
7775   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7776   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7777 }
7778 
7779 
7780 
7781 
7782 
7783 
7784 
7785 
7786 
7787 
7788 
7789 
7790 
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 
7801 
7802 #define KBSTATP         0x64    
7803 #define KBS_DIB         0x01    
7804 #define KBDATAP         0x60    
7805 
7806 #define NO              0
7807 
7808 #define SHIFT           (1<<0)
7809 #define CTL             (1<<1)
7810 #define ALT             (1<<2)
7811 
7812 #define CAPSLOCK        (1<<3)
7813 #define NUMLOCK         (1<<4)
7814 #define SCROLLLOCK      (1<<5)
7815 
7816 #define E0ESC           (1<<6)
7817 
7818 
7819 #define KEY_HOME        0xE0
7820 #define KEY_END         0xE1
7821 #define KEY_UP          0xE2
7822 #define KEY_DN          0xE3
7823 #define KEY_LF          0xE4
7824 #define KEY_RT          0xE5
7825 #define KEY_PGUP        0xE6
7826 #define KEY_PGDN        0xE7
7827 #define KEY_INS         0xE8
7828 #define KEY_DEL         0xE9
7829 
7830 
7831 #define C(x) (x - '@')
7832 
7833 static uchar shiftcode[256] =
7834 {
7835   [0x1D] CTL,
7836   [0x2A] SHIFT,
7837   [0x36] SHIFT,
7838   [0x38] ALT,
7839   [0x9D] CTL,
7840   [0xB8] ALT
7841 };
7842 
7843 static uchar togglecode[256] =
7844 {
7845   [0x3A] CAPSLOCK,
7846   [0x45] NUMLOCK,
7847   [0x46] SCROLLLOCK
7848 };
7849 
7850 static uchar normalmap[256] =
7851 {
7852   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7853   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7854   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7855   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7856   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7857   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7858   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7859   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7860   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7861   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7862   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7863   [0x9C] '\n',      
7864   [0xB5] '/',       
7865   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7866   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7867   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7868   [0x97] KEY_HOME,  [0xCF] KEY_END,
7869   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7870 };
7871 
7872 static uchar shiftmap[256] =
7873 {
7874   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7875   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7876   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7877   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7878   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7879   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7880   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7881   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7882   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7883   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7884   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7885   [0x9C] '\n',      
7886   [0xB5] '/',       
7887   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7888   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7889   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7890   [0x97] KEY_HOME,  [0xCF] KEY_END,
7891   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7892 };
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 static uchar ctlmap[256] =
7901 {
7902   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7903   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7904   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7905   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7906   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7907   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7908   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7909   [0x9C] '\r',      
7910   [0xB5] C('/'),    
7911   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7912   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7913   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7914   [0x97] KEY_HOME,  [0xCF] KEY_END,
7915   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7916 };
7917 
7918 
7919 
7920 
7921 
7922 
7923 
7924 
7925 
7926 
7927 
7928 
7929 
7930 
7931 
7932 
7933 
7934 
7935 
7936 
7937 
7938 
7939 
7940 
7941 
7942 
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 #include "types.h"
7951 #include "x86.h"
7952 #include "defs.h"
7953 #include "kbd.h"
7954 
7955 int
7956 kbdgetc(void)
7957 {
7958   static uint shift;
7959   static uchar *charcode[4] = {
7960     normalmap, shiftmap, ctlmap, ctlmap
7961   };
7962   uint st, data, c;
7963 
7964   st = inb(KBSTATP);
7965   if((st & KBS_DIB) == 0)
7966     return -1;
7967   data = inb(KBDATAP);
7968 
7969   if(data == 0xE0){
7970     shift |= E0ESC;
7971     return 0;
7972   } else if(data & 0x80){
7973     
7974     data = (shift & E0ESC ? data : data & 0x7F);
7975     shift &= ~(shiftcode[data] | E0ESC);
7976     return 0;
7977   } else if(shift & E0ESC){
7978     
7979     data |= 0x80;
7980     shift &= ~E0ESC;
7981   }
7982 
7983   shift |= shiftcode[data];
7984   shift ^= togglecode[data];
7985   c = charcode[shift & (CTL | SHIFT)][data];
7986   if(shift & CAPSLOCK){
7987     if('a' <= c && c <= 'z')
7988       c += 'A' - 'a';
7989     else if('A' <= c && c <= 'Z')
7990       c += 'a' - 'A';
7991   }
7992   return c;
7993 }
7994 
7995 void
7996 kbdintr(void)
7997 {
7998   consoleintr(kbdgetc);
7999 }
8000 
8001 
8002 
8003 
8004 #include "types.h"
8005 #include "defs.h"
8006 #include "param.h"
8007 #include "traps.h"
8008 #include "spinlock.h"
8009 #include "sleeplock.h"
8010 #include "fs.h"
8011 #include "file.h"
8012 #include "memlayout.h"
8013 #include "mmu.h"
8014 #include "proc.h"
8015 #include "x86.h"
8016 
8017 static void consputc(int);
8018 
8019 static int panicked = 0;
8020 
8021 static struct {
8022   struct spinlock lock;
8023   int locking;
8024 } cons;
8025 
8026 static void
8027 printint(int xx, int base, int sign)
8028 {
8029   static char digits[] = "0123456789abcdef";
8030   char buf[16];
8031   int i;
8032   uint x;
8033 
8034   if(sign && (sign = xx < 0))
8035     x = -xx;
8036   else
8037     x = xx;
8038 
8039   i = 0;
8040   do{
8041     buf[i++] = digits[x % base];
8042   }while((x /= base) != 0);
8043 
8044   if(sign)
8045     buf[i++] = '-';
8046 
8047   while(--i >= 0)
8048     consputc(buf[i]);
8049 }
8050 
8051 
8052 
8053 
8054 
8055 
8056 
8057 
8058 
8059 
8060 
8061 
8062 
8063 
8064 
8065 
8066 
8067 
8068 
8069 
8070 
8071 
8072 
8073 
8074 
8075 
8076 
8077 
8078 
8079 
8080 
8081 
8082 
8083 
8084 
8085 
8086 
8087 
8088 
8089 
8090 
8091 
8092 
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 
8101 void
8102 cprintf(char *fmt, ...)
8103 {
8104   int i, c, locking;
8105   uint *argp;
8106   char *s;
8107 
8108   locking = cons.locking;
8109   if(locking)
8110     acquire(&cons.lock);
8111 
8112   if (fmt == 0)
8113     panic("null fmt");
8114 
8115   argp = (uint*)(void*)(&fmt + 1);
8116   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8117     if(c != '%'){
8118       consputc(c);
8119       continue;
8120     }
8121     c = fmt[++i] & 0xff;
8122     if(c == 0)
8123       break;
8124     switch(c){
8125     case 'd':
8126       printint(*argp++, 10, 1);
8127       break;
8128     case 'x':
8129     case 'p':
8130       printint(*argp++, 16, 0);
8131       break;
8132     case 's':
8133       if((s = (char*)*argp++) == 0)
8134         s = "(null)";
8135       for(; *s; s++)
8136         consputc(*s);
8137       break;
8138     case '%':
8139       consputc('%');
8140       break;
8141     default:
8142       
8143       consputc('%');
8144       consputc(c);
8145       break;
8146     }
8147   }
8148 
8149 
8150   if(locking)
8151     release(&cons.lock);
8152 }
8153 
8154 void
8155 panic(char *s)
8156 {
8157   int i;
8158   uint pcs[10];
8159 
8160   cli();
8161   cons.locking = 0;
8162   
8163   cprintf("lapicid %d: panic: ", lapicid());
8164   cprintf(s);
8165   cprintf("\n");
8166   getcallerpcs(&s, pcs);
8167   for(i=0; i<10; i++)
8168     cprintf(" %p", pcs[i]);
8169   panicked = 1; 
8170   for(;;)
8171     ;
8172 }
8173 
8174 
8175 
8176 
8177 
8178 
8179 
8180 
8181 
8182 
8183 
8184 
8185 
8186 
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 #define BACKSPACE 0x100
8201 #define CRTPORT 0x3d4
8202 static ushort *crt = (ushort*)P2V(0xb8000);  
8203 
8204 static void
8205 cgaputc(int c)
8206 {
8207   int pos;
8208 
8209   
8210   outb(CRTPORT, 14);
8211   pos = inb(CRTPORT+1) << 8;
8212   outb(CRTPORT, 15);
8213   pos |= inb(CRTPORT+1);
8214 
8215   if(c == '\n')
8216     pos += 80 - pos%80;
8217   else if(c == BACKSPACE){
8218     if(pos > 0) --pos;
8219   } else
8220     crt[pos++] = (c&0xff) | 0x0700;  
8221 
8222   if(pos < 0 || pos > 25*80)
8223     panic("pos under/overflow");
8224 
8225   if((pos/80) >= 24){  
8226     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8227     pos -= 80;
8228     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8229   }
8230 
8231   outb(CRTPORT, 14);
8232   outb(CRTPORT+1, pos>>8);
8233   outb(CRTPORT, 15);
8234   outb(CRTPORT+1, pos);
8235   crt[pos] = ' ' | 0x0700;
8236 }
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 void
8251 consputc(int c)
8252 {
8253   if(panicked){
8254     cli();
8255     for(;;)
8256       ;
8257   }
8258 
8259   if(c == BACKSPACE){
8260     uartputc('\b'); uartputc(' '); uartputc('\b');
8261   } else
8262     uartputc(c);
8263   cgaputc(c);
8264 }
8265 
8266 #define INPUT_BUF 128
8267 struct {
8268   char buf[INPUT_BUF];
8269   uint r;  
8270   uint w;  
8271   uint e;  
8272 } input;
8273 
8274 #define C(x)  ((x)-'@')  
8275 
8276 void
8277 consoleintr(int (*getc)(void))
8278 {
8279   int c, doprocdump = 0;
8280 
8281   acquire(&cons.lock);
8282   while((c = getc()) >= 0){
8283     switch(c){
8284     case C('P'):  
8285       
8286       doprocdump = 1;
8287       break;
8288     case C('U'):  
8289       while(input.e != input.w &&
8290             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8291         input.e--;
8292         consputc(BACKSPACE);
8293       }
8294       break;
8295     case C('H'): case '\x7f':  
8296       if(input.e != input.w){
8297         input.e--;
8298         consputc(BACKSPACE);
8299       }
8300       break;
8301     default:
8302       if(c != 0 && input.e-input.r < INPUT_BUF){
8303         c = (c == '\r') ? '\n' : c;
8304         input.buf[input.e++ % INPUT_BUF] = c;
8305         consputc(c);
8306         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8307           input.w = input.e;
8308           wakeup(&input.r);
8309         }
8310       }
8311       break;
8312     }
8313   }
8314   release(&cons.lock);
8315   if(doprocdump) {
8316     procdump();  
8317   }
8318 }
8319 
8320 int
8321 consoleread(struct inode *ip, char *dst, int n)
8322 {
8323   uint target;
8324   int c;
8325 
8326   iunlock(ip);
8327   target = n;
8328   acquire(&cons.lock);
8329   while(n > 0){
8330     while(input.r == input.w){
8331       if(myproc()->killed){
8332         release(&cons.lock);
8333         ilock(ip);
8334         return -1;
8335       }
8336       sleep(&input.r, &cons.lock);
8337     }
8338     c = input.buf[input.r++ % INPUT_BUF];
8339     if(c == C('D')){  
8340       if(n < target){
8341         
8342         
8343         input.r--;
8344       }
8345       break;
8346     }
8347     *dst++ = c;
8348     --n;
8349     if(c == '\n')
8350       break;
8351   }
8352   release(&cons.lock);
8353   ilock(ip);
8354 
8355   return target - n;
8356 }
8357 
8358 int
8359 consolewrite(struct inode *ip, char *buf, int n)
8360 {
8361   int i;
8362 
8363   iunlock(ip);
8364   acquire(&cons.lock);
8365   for(i = 0; i < n; i++)
8366     consputc(buf[i] & 0xff);
8367   release(&cons.lock);
8368   ilock(ip);
8369 
8370   return n;
8371 }
8372 
8373 void
8374 consoleinit(void)
8375 {
8376   initlock(&cons.lock, "console");
8377 
8378   devsw[CONSOLE].write = consolewrite;
8379   devsw[CONSOLE].read = consoleread;
8380   cons.locking = 1;
8381 
8382   ioapicenable(IRQ_KBD, 0);
8383 }
8384 
8385 
8386 
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 
8401 
8402 #include "types.h"
8403 #include "defs.h"
8404 #include "param.h"
8405 #include "traps.h"
8406 #include "spinlock.h"
8407 #include "sleeplock.h"
8408 #include "fs.h"
8409 #include "file.h"
8410 #include "mmu.h"
8411 #include "proc.h"
8412 #include "x86.h"
8413 
8414 #define COM1    0x3f8
8415 
8416 static int uart;    
8417 
8418 void
8419 uartinit(void)
8420 {
8421   char *p;
8422 
8423   
8424   outb(COM1+2, 0);
8425 
8426   
8427   outb(COM1+3, 0x80);    
8428   outb(COM1+0, 115200/9600);
8429   outb(COM1+1, 0);
8430   outb(COM1+3, 0x03);    
8431   outb(COM1+4, 0);
8432   outb(COM1+1, 0x01);    
8433 
8434   
8435   if(inb(COM1+5) == 0xFF)
8436     return;
8437   uart = 1;
8438 
8439   
8440   
8441   inb(COM1+2);
8442   inb(COM1+0);
8443   ioapicenable(IRQ_COM1, 0);
8444 
8445   
8446   for(p="xv6...\n"; *p; p++)
8447     uartputc(*p);
8448 }
8449 
8450 void
8451 uartputc(int c)
8452 {
8453   int i;
8454 
8455   if(!uart)
8456     return;
8457   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8458     microdelay(10);
8459   outb(COM1+0, c);
8460 }
8461 
8462 static int
8463 uartgetc(void)
8464 {
8465   if(!uart)
8466     return -1;
8467   if(!(inb(COM1+5) & 0x01))
8468     return -1;
8469   return inb(COM1+0);
8470 }
8471 
8472 void
8473 uartintr(void)
8474 {
8475   consoleintr(uartgetc);
8476 }
8477 
8478 
8479 
8480 
8481 
8482 
8483 
8484 
8485 
8486 
8487 
8488 
8489 
8490 
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 
8501 
8502 
8503 
8504 
8505 
8506 
8507 
8508 .globl start
8509 start:
8510   pushl $argv
8511   pushl $init
8512   pushl $0  
8513   movl $SYS_exec, %eax
8514   int $T_SYSCALL
8515 
8516 
8517 exit:
8518   movl $SYS_exit, %eax
8519   int $T_SYSCALL
8520   jmp exit
8521 
8522 
8523 init:
8524   .string "/init\0"
8525 
8526 
8527 .p2align 2
8528 argv:
8529   .long init
8530   .long 0
8531 
8532 
8533 
8534 
8535 
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 
8552 
8553 
8554   .globl name; \
8555   name: \
8556     movl $SYS_ 
8557     int $T_SYSCALL; \
8558     ret
8559 
8560 SYSCALL(fork)
8561 SYSCALL(exit)
8562 SYSCALL(wait)
8563 SYSCALL(pipe)
8564 SYSCALL(read)
8565 SYSCALL(write)
8566 SYSCALL(close)
8567 SYSCALL(kill)
8568 SYSCALL(exec)
8569 SYSCALL(open)
8570 SYSCALL(mknod)
8571 SYSCALL(unlink)
8572 SYSCALL(fstat)
8573 SYSCALL(link)
8574 SYSCALL(mkdir)
8575 SYSCALL(chdir)
8576 SYSCALL(dup)
8577 SYSCALL(getpid)
8578 SYSCALL(sbrk)
8579 SYSCALL(sleep)
8580 SYSCALL(uptime)
8581 SYSCALL(getreadcount)
8582 
8583 
8584 
8585 
8586 
8587 
8588 
8589 
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 
8601 
8602 #include "types.h"
8603 #include "stat.h"
8604 #include "user.h"
8605 #include "fcntl.h"
8606 
8607 char *argv[] = { "sh", 0 };
8608 
8609 int
8610 main(void)
8611 {
8612   int pid, wpid;
8613 
8614   if(open("console", O_RDWR) < 0){
8615     mknod("console", 1, 1);
8616     open("console", O_RDWR);
8617   }
8618   dup(0);  
8619   dup(0);  
8620 
8621   for(;;){
8622     printf(1, "init: starting sh\n");
8623     pid = fork();
8624     if(pid < 0){
8625       printf(1, "init: fork failed\n");
8626       exit();
8627     }
8628     if(pid == 0){
8629       exec("sh", argv);
8630       printf(1, "init: exec sh failed\n");
8631       exit();
8632     }
8633     while((wpid=wait()) >= 0 && wpid != pid)
8634       printf(1, "zombie!\n");
8635   }
8636 }
8637 
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 
8651 
8652 #include "types.h"
8653 #include "user.h"
8654 #include "fcntl.h"
8655 
8656 
8657 #define EXEC  1
8658 #define REDIR 2
8659 #define PIPE  3
8660 #define LIST  4
8661 #define BACK  5
8662 
8663 #define MAXARGS 10
8664 
8665 struct cmd {
8666   int type;
8667 };
8668 
8669 struct execcmd {
8670   int type;
8671   char *argv[MAXARGS];
8672   char *eargv[MAXARGS];
8673 };
8674 
8675 struct redircmd {
8676   int type;
8677   struct cmd *cmd;
8678   char *file;
8679   char *efile;
8680   int mode;
8681   int fd;
8682 };
8683 
8684 struct pipecmd {
8685   int type;
8686   struct cmd *left;
8687   struct cmd *right;
8688 };
8689 
8690 struct listcmd {
8691   int type;
8692   struct cmd *left;
8693   struct cmd *right;
8694 };
8695 
8696 struct backcmd {
8697   int type;
8698   struct cmd *cmd;
8699 };
8700 int fork1(void);  
8701 void panic(char*);
8702 struct cmd *parsecmd(char*);
8703 
8704 
8705 void
8706 runcmd(struct cmd *cmd)
8707 {
8708   int p[2];
8709   struct backcmd *bcmd;
8710   struct execcmd *ecmd;
8711   struct listcmd *lcmd;
8712   struct pipecmd *pcmd;
8713   struct redircmd *rcmd;
8714 
8715   if(cmd == 0)
8716     exit();
8717 
8718   switch(cmd->type){
8719   default:
8720     panic("runcmd");
8721 
8722   case EXEC:
8723     ecmd = (struct execcmd*)cmd;
8724     if(ecmd->argv[0] == 0)
8725       exit();
8726     exec(ecmd->argv[0], ecmd->argv);
8727     printf(2, "exec %s failed\n", ecmd->argv[0]);
8728     break;
8729 
8730   case REDIR:
8731     rcmd = (struct redircmd*)cmd;
8732     close(rcmd->fd);
8733     if(open(rcmd->file, rcmd->mode) < 0){
8734       printf(2, "open %s failed\n", rcmd->file);
8735       exit();
8736     }
8737     runcmd(rcmd->cmd);
8738     break;
8739 
8740   case LIST:
8741     lcmd = (struct listcmd*)cmd;
8742     if(fork1() == 0)
8743       runcmd(lcmd->left);
8744     wait();
8745     runcmd(lcmd->right);
8746     break;
8747 
8748 
8749 
8750   case PIPE:
8751     pcmd = (struct pipecmd*)cmd;
8752     if(pipe(p) < 0)
8753       panic("pipe");
8754     if(fork1() == 0){
8755       close(1);
8756       dup(p[1]);
8757       close(p[0]);
8758       close(p[1]);
8759       runcmd(pcmd->left);
8760     }
8761     if(fork1() == 0){
8762       close(0);
8763       dup(p[0]);
8764       close(p[0]);
8765       close(p[1]);
8766       runcmd(pcmd->right);
8767     }
8768     close(p[0]);
8769     close(p[1]);
8770     wait();
8771     wait();
8772     break;
8773 
8774   case BACK:
8775     bcmd = (struct backcmd*)cmd;
8776     if(fork1() == 0)
8777       runcmd(bcmd->cmd);
8778     break;
8779   }
8780   exit();
8781 }
8782 
8783 int
8784 getcmd(char *buf, int nbuf)
8785 {
8786   printf(2, "$ ");
8787   memset(buf, 0, nbuf);
8788   gets(buf, nbuf);
8789   if(buf[0] == 0) 
8790     return -1;
8791   return 0;
8792 }
8793 
8794 
8795 
8796 
8797 
8798 
8799 
8800 int
8801 main(void)
8802 {
8803   static char buf[100];
8804   int fd;
8805 
8806   
8807   while((fd = open("console", O_RDWR)) >= 0){
8808     if(fd >= 3){
8809       close(fd);
8810       break;
8811     }
8812   }
8813 
8814   
8815   while(getcmd(buf, sizeof(buf)) >= 0){
8816     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8817       
8818       buf[strlen(buf)-1] = 0;  
8819       if(chdir(buf+3) < 0)
8820         printf(2, "cannot cd %s\n", buf+3);
8821       continue;
8822     }
8823     if(fork1() == 0)
8824       runcmd(parsecmd(buf));
8825     wait();
8826   }
8827   exit();
8828 }
8829 
8830 void
8831 panic(char *s)
8832 {
8833   printf(2, "%s\n", s);
8834   exit();
8835 }
8836 
8837 int
8838 fork1(void)
8839 {
8840   int pid;
8841 
8842   pid = fork();
8843   if(pid == -1)
8844     panic("fork");
8845   return pid;
8846 }
8847 
8848 
8849 
8850 
8851 
8852 struct cmd*
8853 execcmd(void)
8854 {
8855   struct execcmd *cmd;
8856 
8857   cmd = malloc(sizeof(*cmd));
8858   memset(cmd, 0, sizeof(*cmd));
8859   cmd->type = EXEC;
8860   return (struct cmd*)cmd;
8861 }
8862 
8863 struct cmd*
8864 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8865 {
8866   struct redircmd *cmd;
8867 
8868   cmd = malloc(sizeof(*cmd));
8869   memset(cmd, 0, sizeof(*cmd));
8870   cmd->type = REDIR;
8871   cmd->cmd = subcmd;
8872   cmd->file = file;
8873   cmd->efile = efile;
8874   cmd->mode = mode;
8875   cmd->fd = fd;
8876   return (struct cmd*)cmd;
8877 }
8878 
8879 struct cmd*
8880 pipecmd(struct cmd *left, struct cmd *right)
8881 {
8882   struct pipecmd *cmd;
8883 
8884   cmd = malloc(sizeof(*cmd));
8885   memset(cmd, 0, sizeof(*cmd));
8886   cmd->type = PIPE;
8887   cmd->left = left;
8888   cmd->right = right;
8889   return (struct cmd*)cmd;
8890 }
8891 
8892 
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 struct cmd*
8901 listcmd(struct cmd *left, struct cmd *right)
8902 {
8903   struct listcmd *cmd;
8904 
8905   cmd = malloc(sizeof(*cmd));
8906   memset(cmd, 0, sizeof(*cmd));
8907   cmd->type = LIST;
8908   cmd->left = left;
8909   cmd->right = right;
8910   return (struct cmd*)cmd;
8911 }
8912 
8913 struct cmd*
8914 backcmd(struct cmd *subcmd)
8915 {
8916   struct backcmd *cmd;
8917 
8918   cmd = malloc(sizeof(*cmd));
8919   memset(cmd, 0, sizeof(*cmd));
8920   cmd->type = BACK;
8921   cmd->cmd = subcmd;
8922   return (struct cmd*)cmd;
8923 }
8924 
8925 
8926 
8927 
8928 
8929 
8930 
8931 
8932 
8933 
8934 
8935 
8936 
8937 
8938 
8939 
8940 
8941 
8942 
8943 
8944 
8945 
8946 
8947 
8948 
8949 
8950 
8951 
8952 char whitespace[] = " \t\r\n\v";
8953 char symbols[] = "<|>&;()";
8954 
8955 int
8956 gettoken(char **ps, char *es, char **q, char **eq)
8957 {
8958   char *s;
8959   int ret;
8960 
8961   s = *ps;
8962   while(s < es && strchr(whitespace, *s))
8963     s++;
8964   if(q)
8965     *q = s;
8966   ret = *s;
8967   switch(*s){
8968   case 0:
8969     break;
8970   case '|':
8971   case '(':
8972   case ')':
8973   case ';':
8974   case '&':
8975   case '<':
8976     s++;
8977     break;
8978   case '>':
8979     s++;
8980     if(*s == '>'){
8981       ret = '+';
8982       s++;
8983     }
8984     break;
8985   default:
8986     ret = 'a';
8987     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8988       s++;
8989     break;
8990   }
8991   if(eq)
8992     *eq = s;
8993 
8994   while(s < es && strchr(whitespace, *s))
8995     s++;
8996   *ps = s;
8997   return ret;
8998 }
8999 
9000 int
9001 peek(char **ps, char *es, char *toks)
9002 {
9003   char *s;
9004 
9005   s = *ps;
9006   while(s < es && strchr(whitespace, *s))
9007     s++;
9008   *ps = s;
9009   return *s && strchr(toks, *s);
9010 }
9011 
9012 struct cmd *parseline(char**, char*);
9013 struct cmd *parsepipe(char**, char*);
9014 struct cmd *parseexec(char**, char*);
9015 struct cmd *nulterminate(struct cmd*);
9016 
9017 struct cmd*
9018 parsecmd(char *s)
9019 {
9020   char *es;
9021   struct cmd *cmd;
9022 
9023   es = s + strlen(s);
9024   cmd = parseline(&s, es);
9025   peek(&s, es, "");
9026   if(s != es){
9027     printf(2, "leftovers: %s\n", s);
9028     panic("syntax");
9029   }
9030   nulterminate(cmd);
9031   return cmd;
9032 }
9033 
9034 struct cmd*
9035 parseline(char **ps, char *es)
9036 {
9037   struct cmd *cmd;
9038 
9039   cmd = parsepipe(ps, es);
9040   while(peek(ps, es, "&")){
9041     gettoken(ps, es, 0, 0);
9042     cmd = backcmd(cmd);
9043   }
9044   if(peek(ps, es, ";")){
9045     gettoken(ps, es, 0, 0);
9046     cmd = listcmd(cmd, parseline(ps, es));
9047   }
9048   return cmd;
9049 }
9050 struct cmd*
9051 parsepipe(char **ps, char *es)
9052 {
9053   struct cmd *cmd;
9054 
9055   cmd = parseexec(ps, es);
9056   if(peek(ps, es, "|")){
9057     gettoken(ps, es, 0, 0);
9058     cmd = pipecmd(cmd, parsepipe(ps, es));
9059   }
9060   return cmd;
9061 }
9062 
9063 struct cmd*
9064 parseredirs(struct cmd *cmd, char **ps, char *es)
9065 {
9066   int tok;
9067   char *q, *eq;
9068 
9069   while(peek(ps, es, "<>")){
9070     tok = gettoken(ps, es, 0, 0);
9071     if(gettoken(ps, es, &q, &eq) != 'a')
9072       panic("missing file for redirection");
9073     switch(tok){
9074     case '<':
9075       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9076       break;
9077     case '>':
9078       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9079       break;
9080     case '+':  
9081       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9082       break;
9083     }
9084   }
9085   return cmd;
9086 }
9087 
9088 
9089 
9090 
9091 
9092 
9093 
9094 
9095 
9096 
9097 
9098 
9099 
9100 struct cmd*
9101 parseblock(char **ps, char *es)
9102 {
9103   struct cmd *cmd;
9104 
9105   if(!peek(ps, es, "("))
9106     panic("parseblock");
9107   gettoken(ps, es, 0, 0);
9108   cmd = parseline(ps, es);
9109   if(!peek(ps, es, ")"))
9110     panic("syntax - missing )");
9111   gettoken(ps, es, 0, 0);
9112   cmd = parseredirs(cmd, ps, es);
9113   return cmd;
9114 }
9115 
9116 struct cmd*
9117 parseexec(char **ps, char *es)
9118 {
9119   char *q, *eq;
9120   int tok, argc;
9121   struct execcmd *cmd;
9122   struct cmd *ret;
9123 
9124   if(peek(ps, es, "("))
9125     return parseblock(ps, es);
9126 
9127   ret = execcmd();
9128   cmd = (struct execcmd*)ret;
9129 
9130   argc = 0;
9131   ret = parseredirs(ret, ps, es);
9132   while(!peek(ps, es, "|)&;")){
9133     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9134       break;
9135     if(tok != 'a')
9136       panic("syntax");
9137     cmd->argv[argc] = q;
9138     cmd->eargv[argc] = eq;
9139     argc++;
9140     if(argc >= MAXARGS)
9141       panic("too many args");
9142     ret = parseredirs(ret, ps, es);
9143   }
9144   cmd->argv[argc] = 0;
9145   cmd->eargv[argc] = 0;
9146   return ret;
9147 }
9148 
9149 
9150 
9151 struct cmd*
9152 nulterminate(struct cmd *cmd)
9153 {
9154   int i;
9155   struct backcmd *bcmd;
9156   struct execcmd *ecmd;
9157   struct listcmd *lcmd;
9158   struct pipecmd *pcmd;
9159   struct redircmd *rcmd;
9160 
9161   if(cmd == 0)
9162     return 0;
9163 
9164   switch(cmd->type){
9165   case EXEC:
9166     ecmd = (struct execcmd*)cmd;
9167     for(i=0; ecmd->argv[i]; i++)
9168       *ecmd->eargv[i] = 0;
9169     break;
9170 
9171   case REDIR:
9172     rcmd = (struct redircmd*)cmd;
9173     nulterminate(rcmd->cmd);
9174     *rcmd->efile = 0;
9175     break;
9176 
9177   case PIPE:
9178     pcmd = (struct pipecmd*)cmd;
9179     nulterminate(pcmd->left);
9180     nulterminate(pcmd->right);
9181     break;
9182 
9183   case LIST:
9184     lcmd = (struct listcmd*)cmd;
9185     nulterminate(lcmd->left);
9186     nulterminate(lcmd->right);
9187     break;
9188 
9189   case BACK:
9190     bcmd = (struct backcmd*)cmd;
9191     nulterminate(bcmd->cmd);
9192     break;
9193   }
9194   return cmd;
9195 }
9196 
9197 
9198 
9199 
9200 
9201 
9202 
9203 
9204 
9205 
9206 
9207 
9208 
9209 .code16                       
9210 .globl start
9211 start:
9212   cli                         
9213 
9214   
9215   xorw    %ax,%ax             
9216   movw    %ax,%ds             
9217   movw    %ax,%es             
9218   movw    %ax,%ss             
9219 
9220   
9221   
9222 seta20.1:
9223   inb     $0x64,%al               
9224   testb   $0x2,%al
9225   jnz     seta20.1
9226 
9227   movb    $0xd1,%al               
9228   outb    %al,$0x64
9229 
9230 seta20.2:
9231   inb     $0x64,%al               
9232   testb   $0x2,%al
9233   jnz     seta20.2
9234 
9235   movb    $0xdf,%al               
9236   outb    %al,$0x60
9237 
9238   
9239   
9240   
9241   lgdt    gdtdesc
9242   movl    %cr0, %eax
9243   orl     $CR0_PE, %eax
9244   movl    %eax, %cr0
9245 
9246 
9247 
9248 
9249 
9250   
9251   
9252   
9253   ljmp    $(SEG_KCODE<<3), $start32
9254 
9255 .code32  
9256 start32:
9257   
9258   movw    $(SEG_KDATA<<3), %ax    
9259   movw    %ax, %ds                
9260   movw    %ax, %es                
9261   movw    %ax, %ss                
9262   movw    $0, %ax                 
9263   movw    %ax, %fs                
9264   movw    %ax, %gs                
9265 
9266   
9267   movl    $start, %esp
9268   call    bootmain
9269 
9270   
9271   
9272   movw    $0x8a00, %ax            
9273   movw    %ax, %dx
9274   outw    %ax, %dx
9275   movw    $0x8ae0, %ax            
9276   outw    %ax, %dx
9277 spin:
9278   jmp     spin
9279 
9280 
9281 .p2align 2                                
9282 gdt:
9283   SEG_NULLASM                             
9284   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9285   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9286 
9287 gdtdesc:
9288   .word   (gdtdesc - gdt - 1)             
9289   .long   gdt                             
9290 
9291 
9292 
9293 
9294 
9295 
9296 
9297 
9298 
9299 
9300 
9301 
9302 
9303 
9304 
9305 
9306 
9307 #include "types.h"
9308 #include "elf.h"
9309 #include "x86.h"
9310 #include "memlayout.h"
9311 
9312 #define SECTSIZE  512
9313 
9314 void readseg(uchar*, uint, uint);
9315 
9316 void
9317 bootmain(void)
9318 {
9319   struct elfhdr *elf;
9320   struct proghdr *ph, *eph;
9321   void (*entry)(void);
9322   uchar* pa;
9323 
9324   elf = (struct elfhdr*)0x10000;  
9325 
9326   
9327   readseg((uchar*)elf, 4096, 0);
9328 
9329   
9330   if(elf->magic != ELF_MAGIC)
9331     return;  
9332 
9333   
9334   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9335   eph = ph + elf->phnum;
9336   for(; ph < eph; ph++){
9337     pa = (uchar*)ph->paddr;
9338     readseg(pa, ph->filesz, ph->off);
9339     if(ph->memsz > ph->filesz)
9340       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9341   }
9342 
9343   
9344   
9345   entry = (void(*)(void))(elf->entry);
9346   entry();
9347 }
9348 
9349 
9350 void
9351 waitdisk(void)
9352 {
9353   
9354   while((inb(0x1F7) & 0xC0) != 0x40)
9355     ;
9356 }
9357 
9358 
9359 void
9360 readsect(void *dst, uint offset)
9361 {
9362   
9363   waitdisk();
9364   outb(0x1F2, 1);   
9365   outb(0x1F3, offset);
9366   outb(0x1F4, offset >> 8);
9367   outb(0x1F5, offset >> 16);
9368   outb(0x1F6, (offset >> 24) | 0xE0);
9369   outb(0x1F7, 0x20);  
9370 
9371   
9372   waitdisk();
9373   insl(0x1F0, dst, SECTSIZE/4);
9374 }
9375 
9376 
9377 
9378 void
9379 readseg(uchar* pa, uint count, uint offset)
9380 {
9381   uchar* epa;
9382 
9383   epa = pa + count;
9384 
9385   
9386   pa -= offset % SECTSIZE;
9387 
9388   
9389   offset = (offset / SECTSIZE) + 1;
9390 
9391   
9392   
9393   
9394   for(; pa < epa; pa += SECTSIZE, offset++)
9395     readsect(pa, offset);
9396 }
9397 
9398 
9399 
9400 /* Simple linker script for the JOS kernel.
9401    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
9402 
9403 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
9404 OUTPUT_ARCH(i386)
9405 ENTRY(_start)
9406 
9407 SECTIONS
9408 {
9409 	/* Link the kernel at this address: "." means the current address */
9410         /* Must be equal to KERNLINK */
9411 	. = 0x80100000;
9412 
9413 	.text : AT(0x100000) {
9414 		*(.text .stub .text.* .gnu.linkonce.t.*)
9415 	}
9416 
9417 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
9418 
9419 	.rodata : {
9420 		*(.rodata .rodata.* .gnu.linkonce.r.*)
9421 	}
9422 
9423 	/* Include debugging information in kernel memory */
9424 	.stab : {
9425 		PROVIDE(__STAB_BEGIN__ = .);
9426 		*(.stab);
9427 		PROVIDE(__STAB_END__ = .);
9428 	}
9429 
9430 	.stabstr : {
9431 		PROVIDE(__STABSTR_BEGIN__ = .);
9432 		*(.stabstr);
9433 		PROVIDE(__STABSTR_END__ = .);
9434 	}
9435 
9436 	/* Adjust the address for the data segment to the next page */
9437 	. = ALIGN(0x1000);
9438 
9439 	/* Conventionally, Unix linkers provide pseudo-symbols
9440 	 * etext, edata, and end, at the end of the text, data, and bss.
9441 	 * For the kernel mapping, we need the address at the beginning
9442 	 * of the data section, but that's not one of the conventional
9443 	 * symbols, because the convention started before there was a
9444 	 * read-only rodata section between text and data. */
9445 	PROVIDE(data = .);
9446 
9447 
9448 
9449 
9450 	/* The data segment */
9451 	.data : {
9452 		*(.data)
9453 	}
9454 
9455 	PROVIDE(edata = .);
9456 
9457 	.bss : {
9458 		*(.bss)
9459 	}
9460 
9461 	PROVIDE(end = .);
9462 
9463 	/DISCARD/ : {
9464 		*(.eh_frame .note.GNU-stack)
9465 	}
9466 }
9467 
9468 
9469 
9470 
9471 
9472 
9473 
9474 
9475 
9476 
9477 
9478 
9479 
9480 
9481 
9482 
9483 
9484 
9485 
9486 
9487 
9488 
9489 
9490 
9491 
9492 
9493 
9494 
9495 
9496 
9497 
9498 
9499 
